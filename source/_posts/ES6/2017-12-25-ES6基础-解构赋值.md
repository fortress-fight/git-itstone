---
title: ES6基础 解构赋值
tags:
  - javascript
  - es6
  - 前端
categories:
  - ECMAScript6
folder: es6
abbrlink: d9353875
photos: /xmind/ES6/解构赋值.png
date: 2017-12-25 23:15:30
---

******

<!-- more -->

# ES6 基础 -- 解构赋值

对象和字面量是 JavaScript 中两种最为常见的数据结构，在 ECMAScript 6 中添加了可以简化从字面量中提取信息这一步骤的方法 -- 解构；

## 为何要使用解构

示例：

```js
    var obj = {
        name: '小明',
        age: '24',
        job: 'student',
        friends: ['小白'， '小红']
    }
```

这时如果我们希望提取所有信息，可能会选择这样做；

```js
    var name = obj.name;
    var age = obj.age;
    ...
```

这里变量还算不多所以，即使是这种笨拙的方法也是可以胜任的，但是如果遇到复杂的数据结构或者大量的数据都会使得提取信息变得十分繁琐。而 ES6 中的解构方式就可以很好的解决这个问题；

```js
    let {name, age, job, friends} = obj;
    console.log(name, age, job, friends); //  小明 24 student [ '小白', '小红' ]
```

******

## 对象的解构

在上面的示例中我们使用的是对象的字面量形式，表现为：在赋值操作符左边放置一个对象字面量；

示例：

```js learn01 - 01
    let example = {
    type: "object",
    index: "01"
    };

    let { type, index } = example;

    console.log(type, index); // object 01
```

这里的 `type` 和 `index` 都是局部变量，也是用来从 example 中读取相应值得属性名称；
我们还需要注意的是, 在使用解构的时候，必须要提供初始化程序（等号右侧的值），如果缺少初始化程序，将会抛出语法错误；

```js
    let {type, index};
    //  Missing initializer in destructuring declaration
```

> 注：这里的 `{type, index}` 是 ES6 中规定的对象字面量属性初始化的简写方式，相当于 `{type: type, index: index}`

### 对象的解构赋值

我们可以通过上面的方法对一个对象进行解构，抽取我们所需要的信息；我们还可以通过赋值的方式，找到相应变量，将对象中的信息赋值给他；

```js learn01-02
let example2 = {
  type: "object",
  index: 02
};

let type = null,
  index = 0;

({ type, index } = example2);
console.log(type, index); // object 02
```

这里在进行赋值的使用，将赋值的语句放入了括号中，这是因为 JavaScript 引擎将一对开放的花括号视作一个代码块，而且代码块是不允许出现在赋值语句的左侧的；所以需要添加小括号将块语句转化成为一个表达式，从而实现整个解构赋值的操作；

解构赋值表达式的值与表达式右侧的值相等；

```js
    ...
    ({ type, index } = null); //TypeError: Cannot match against 'undefined' or 'null'.
```

{% blockquote %}
解构赋值表达式的右侧，如果是 null 或者是 undefined 将会导致程序抛出错误。也就是说任何试图读取 null 或者 undefined 的属性的行为都会触发运行错误
{% endblockquote %}

### 对象解构的默认值

在使用解构赋值表达式的时候，如果指定的局部变量名在对象中并不存在，那么这个局部变量会被赋值为 undefined；

```js

    let example3 = { name: "object" };
    let {age} = example3;
    console.log(age) // undefinded

```

这里我们希望在 example3 中查找 age 属性，在没有查找到的情况下将会使用 `undefined` 来对这个变量进行赋值；

除了寄托于这个默认行为，我们还可以对变量赋值一个默认值，这样如果没有查找到的时候将会使用默认值来进行赋值；

```js
    let example3 = { name: "object" };
    let {name = "new",age = 24} = example3;
    console.log(name, age) // object 24
```

这里我们可以看到，由于 example3 中不存在 `age` 属性，所以使用了这个变量的默认值，而 `name` 在 example3 中 存在同名属性，所以赋值成为 `"object"`

### 为非同名局部变量赋值

先看示例：

```js learn01-04
    let example4 = {
        name: "object",
        age: "24"
    };

    let {
        name: newname,
        age: age
    } = example4;

    console.log(newname, age); // object 24
```

这一段使用了解构赋值的方式赋值了 `newname` & `age`; 不同的是 `age` 是和属性名相同的变量，而 `newname` 却不是；
`name: newname` 的语法含义是：读取名为 `name` 的属性，并将其值存储在变量 `newname` 中

当使用其他变量名进行赋值操作的时候，同样可以添加默认值：

```js learn01-04
    let example4 = {
        name: "object",
        age: "24"
    };

    let {
        name: newname,
        age: age,
        job: localjob = 'student'
    } = example4;

    console.log(newname, age, localjob); // object 24 student
```

### 嵌套对象的解构

示例：

```js learn01-05
    let example5 = {
        name: 'obj',
        age: '24',
        pos: {
            x: 100,
            y: 100,
            infor: {
                x: `横向`,
                y: `纵向`
            }
        }
    };

    let {name, pos: {x, infor: {x: inforx}}} = example5;
    console.log(name, x, inforx); // bj 100 横向
```

在解构赋值中，所有冒号前的表示符都代表了在对象中的检索位置，其右侧为被赋值的语句；

> 注意：目前我们可以这样使用 `let {pos: {}} = example05` 这种形式不会产生赋值的操作；目前不会引起运行错误，但是未来可能会废弃这种写法，不建议使用；

******

## 数组解构

示例：

```js learn02-01
    let arr = ['小明', '小花'];

    let [friend1, friend2] = arr;
    console.log(friend1, friend2) // 小明 小花
```

数组的结构相较于对象更为简单一些，无需对着属性进行查找，而是通过位置进行选取，如果等式的右侧是一个不可遍历的值，就会抛出错误；
和对象结构相同的是，在赋值的时候必须提供一个初始化程序；

由于数组本质上是一个对象，所以我们还可以使用对象来解构数组；

```js learn02-01

    let {0:first, length: l} = ['小明', '小花'];
    console.log(first, l); // 小明 2

```

### 数组的解构赋值

数组的解构赋值，无需像对象的结构赋值一样使用小括号包裹

```js learn02-02
    // 02
    let arr = ['小明', '小花'];
    let friend1, friend2;

    [friend1, friend2] = arr;
    console.log(friend1, friend2) // 小明 小花
```

### 数组的默认值

数组的结构赋值表达式中同样可以使用默认值

```js learn02-03
    let arr = ['小明', '小花'];
    let friend1, friend2, friend3, friend4;

    [friend1, friend2] = arr;
    console.log(friend1, friend2, friend3, friend4 = '小白') // 小明 小花 undefined 小白
```

和对象的默认值相同，如果不存在对应项将会使用 `undefined`， 如果存在默认值的情况下，查找不到时将会使用提供的默认值；

### 嵌套数组的解构

```js learn02-04
    let arr = ['小明', '小花', ['花', '鸟', '虫子']];
    let friend1, friend2, animal1, animal2;

    [friend1, friend2, [animal1, animal2]] = arr;
    console.log(friend1, friend2, animal1, animal2) // 小明 小花 花 鸟
```

### 不定元素

在数组中，可以通过 `...` 语法将数组中的剩余元素组成数组赋值给一个特殊变量；

```js learn02-05
    let arr = ['小明', '小花', ['花', '鸟', '虫子']];
    let friend1, other;

    [friend1, ...other] = arr;
    console.log(friend1, other) // 小明 [ '小花', [ '花', '鸟', '虫子' ] ]
```

> 注意： 在使用不定元素的时候，不定元素必须作为最后一个条目使用，在后面继续添加逗号，会产生语法错误

******

## 解构赋值于函数参数

解构赋值可以用于在函数参数的传递中，较为常用的场景是：我们需要一个保护多个参数的对象，作为 option 进行传递，在函数体内我们又需要对其赋予初始值并且为了方便还要提取属性信息；

例如：

```js learn02-06

    function example6 (option) {
        let initOption = {
            name: '06',
            age: 24
        };
        option = Object.assign(initOption, option);
        let name = option.name;
        console.log(option); //{ name: 'haha', age: 24, job: 'student' }
    }

    example6({name: 'haha', job: 'student'})

```

如果使用解构赋值，就可以对这个操作进行简化

```js learn02-07

    // 07

    function example7 ({name=07, age=24, job}) {
        console.log(name, age, job); // haha 24 student
    }

    example7({name: 'haha', job: 'student'})

```

这里可以理解为 `arguments = 传入的参数` 然后对其解构；正因如此如果没有传入参数或传入了 `undefined || null` 都会抛出错误；为了解决这个问题可以对可能缺失的参数赋予默认值；

```js

    function example7 ({name=07, age=24, job} = {}) {
        console.log(name, age, job); // haha 24 student
    }

```

>注意：在使用解构参数的时候，一定要注意如果赋值一个 undefined 或者 null 的话将会抛出错误，如果存在这种可能就需要对其赋予默认值，或者放弃使用解构参数；

******

## 应用实例

1. 交换两个变量的值

    在排序算法中，交换两个变量的值是一件十分常见的操作，在 ES5 中 我们可以这样操作：

    ```js learn03-01

        // 01

        let one = 1, two = 2, tmp;

        tmp = one;
        one = two;
        two = tmp;

        console.log(one, two); // 2 1

    ```

    使用 es6 的解构赋值，我们可以简化这个过程

    ```js learn03-02

        // 02

        let one = 1, two = 2;

        [two, one] = [one, two];

        console.log(one, two); // 2 1

    ```

    在代码执行的过程中，首先是将右侧的进行解构，赋值于左侧，左侧在接收赋值后，就完成了交换的目的；

2. 取出对象的方法

    ```js learn03-03

        // 03

        let {max} = Math;
        console.log(max(100,10,2)); // 100

    ```
    
******

{% img /xmind/ES6/解构赋值.png %}