---
title: ES6基础-类
tags:
  - javascript
  - es6
  - 前端
categories:
  - ECMAScript6
folder: es6
abbrlink: cf3579b2
date: 2018-01-23 23:27:12
---

******

<!-- more -->

## ES6基础 -- 类

大多数面向对象的编程语言都支持类和类集成的特性，但是 JavaScript 却不支持这些特性，而是通过其他方法定义并关联多个相关对象；

尽管一部分 JavaScript 的开发者坚持 JavaScript 中不需要类，但是为了更好的规范实现类的特性，在 ES6 中提引用了类的特性；但是 ES6 中的类依旧是借鉴了 JavaScript 的动态特性，算是一个语法糖；

******

## ES5 中的近类结构

ES5 中实现类的特性的思路是：**首先创建一个构造函数，然后定义另一个方法并赋值给构造函数的原型**

```js learn01.js
    function CreatePerson (name) {
        this.name = name;
    }

    CreatePerson.prototype.sayName = function () {
        console.log(this.name);
    }

    var person1= new CreatePerson('example');

    person1.sayName(); // example

    // 检测继承关系
    console.log(person1 instanceof CreatePerson); // true
    console.log(person1 instanceof Object); // true
```

1. 建立构造函数 `CreatePerson`
2. 给 `CreatePerson` 的原型添加一个 `sayName` 方法
3. 使用 `new` 操作符创建一个 `CreatePerson` 的实例，实例将会继承 `CreatePerson.prototype`；而且由于存在原型继承的特性，所以实例同于也是 `Object` 的实例；
4. 通过 `instanceof` 可以检测实例与构造函数的关系；

******

## ES6 的类结构

### 基本的类声明语法

声明类的格式：`class <类名> {}`；

```js learn02.js
    class CreatePerson {
        constructor (name) {
            this.name = name;
        }

        sayName () {
            console.log(this.name);
        }
    }

    let person = new CreatePerson('example');
    person.sayName(); // example

    console.log(person instanceof CreatePerson); // true
    console.log(person instanceof Object); // true

    console.log(typeof CreatePerson); // function
    console.log(typeof CreatePerson.prototype.sayName); // function

```

这里直接在类中通过特殊的 `constructor` 方法名来定义构造函数；这种类的构造方式使用简介语法来定义方法，因而不需要通过 `function` 关键字来定义；

私有属性是示例中的属性，**私有属性不会存在于原型上，并且只能在类的构造函数或方法中添加**，建议在构造函数中创建所有的私有属性，从而通过一处就可以管理类中的所有私有属性；

通过 `console.log(typeof CreatePerson); // function` 可以看出 ES6 中的类声明是基于已有自定义类型声明的语法糖，`CreatePerson` 声明实际上创建了一个具有构造函数方法行为的函数；而 `sayName` 方法实际上是 `CreatePerson.prototype` 上的一个方法；通过语法糖包装以后，类就可以代替自定义类型的功能

> **与真正的函数不同，类属性不可以被赋予新值，例如：`CreatePerson.prototype` 就是 `CreatePerson` 的只读属性。`CreatePerson.prototype` 本身就是一个对象，我们只能够对该对象的属性和方法进行操作，而不能够使用另一个对象来替换该对象**

******

### ES6 类声明的进一步了解

尽管 ES6 类声明与自定义类型之间有诸多相似之处，但是我们仍是需要知道它们之间的差异：

1. 自定义类型通过函数进行声明，函数声明可以被提升，而类声明与 `let` 类似，不能被提升；在声明之前，它们会存在于临时死区中；
2. 类声明中的所有代码将自动运行在严格模式下，而且无法强行让代码脱离严格模式中执行；
3. 在自定义类型中，需要通过 `Object.defineProperty()` 方法手动指定某个方法为不可枚举；而在类中，所有方法都是不可枚举的。
4. 每一个类都有 `[[Construct]]` 的内部方法，通过关键字 `new` 调用时将会执行 `[[Construct]]` 方法，而没有 `[[Construct]]` 的方法的函数，不能通过 `new` 进行调用。
5. 使用除关键字 `new` 以外的方式调用类的构造函数会导致程序抛出错误，而执行构造函数的话，将会执行 `[[Call]]` 内部方法。
6. 在类中修改类名会导致程序报错。

我们可以模拟类的语法，编写等价代码，创建近类结构：

```js learn03.js
    let CreatePerson = (function () {

        "use strict";
        
        // 模拟 constructor 行为
        const CreatePerson = function (name) {

            if (typeof new.target === 'undefined') {
                throw new Error ('必须通过关键字 new 调用构造函数');
            }

            this.name = name;
        }

        // 模拟定义内部方法
        Object.defineProperty(CreatePerson.prototype, 'sayName', {
            value: function () {

                if (typeof new.target !== 'undefined') {
                    throw new Error('不可使用关键字 new 调用该方法');
                }

                console.log(this.name);
                
            },
            enumerable: false,
            writable: true,
            configurable: true
        });

        return CreatePerson;
    })();

    let person = new CreatePerson('example');

    person.sayName(); // example
```

在外部作用域中的 `CreatePerson` 是通过 `let` 进行声明的，而内部作用域中的 `CreatePerson` 是通过 `const` 进行声明的，所以在内部不能修改 `CreatePerson` 的名称，（ES6 类声明的时候，也不能在内部更换绑定 `new.target` 来限制调用方式；最后将这个定义完成的构造函数返回；

上面的示例模拟了 ES6 中类的实现

******

## ES5 中类的特性

### 一等公民

在程序中，一等公民是指一个可以传入函数，可以从函数中返回，并且可以赋值给变量的值。在 JavaScript 中，函数时作为一等公民存在的；

在 ES6 中，类同样作为一等公民存在，允许通过多种方式使用类的特性；

1. 类作为参数传递

    ```js learn04.js
        function createObject (classDef) {
            return new classDef();
        }

        let obj = createObject(class {
            sayHi() {
                console.log('hello');
            }
        });

        obj.sayHi(); // hello
    ```

    在这个示例中，类作为一个参数进行传递；

2. 立即调用类构造函数

    ```js learn04.js
        let example = new class {
            constructor (name) {
                this.name = name;
            }

            sayName () {
                console.log(this.name);
            }
        } ('example');

        example.sayName(); // example
    ```

    通过这种直接创建的方式，可以创建一个单例，并且不会在作用域中暴露类的引用；

******

### 特殊属性

在使用 class 创建类的时候，我们可以快速创建一些特殊属性

1. 访问器属性

    类是支持在原型上直接定义访问器属性的，创建 getter 时，需要在关键字 get 后紧跟一个空格和相应的标识符；创建 setter 时，只需要将关键字 get 替换成 set；

    ```js learn04.js

        class createPerson {
            constructor() {

                this.infor = {
                    name: 'example'
                }

            }
            set name(value) {
                console.log('设置了 name 值');
                this.infor.name = value;
            }

            get name() {
                console.log('正在获取 name 值');
                return this.infor.name;
            }
        }

        let person = new createPerson();
        console.log(person.name);
        // 正在获取 name 值

    ```

    相当于：

    ```js learn04.js
        
        let createPerson2 = (function () {

            const createPerson2 = function () {

                if (typeof new.target === 'undefined') {
                    throw new Error('必须通过关键字进行调用');
                }

                this.infor = {
                    name: 'example'
                }

            }
            createPerson2.prototype.sayName = function () {
                console.log(this.name);
            };
            Object.defineProperty(createPerson2.prototype, 'name', {
                enumerable: false,
                configurable: true,
                get: function () {
                    return this.infor.name;
                },
                set: function (name) {
                    this.infor.name = name;
                }
            });
            return createPerson2;
        })();

        let example3 = new createPerson2();

        console.log(example3.infor);
        // { name: 'example' }

        example3.infor.name = 'ff';

        console.log(example3.infor);
        // { name: 'ff' }

    ```

2. 可计算成员名称

    和对象字面量相同，在类中同样可以使用 `[methodName] () {}` 作为可计算名称；

3. 静态成员

    先看示例
    
    ```js learn4.js
            
        function createPerson3(name) {
            this.name = name;
        }

        createPerson3.create = (name) => {
            return new createPerson3(name);
        }

        createPerson3.prototype.sayName = function () {
            console.log(this.name);
        }

        let person3 = createPerson3.create('ceshi');
        person3.sayName(); // ceshi
    ```

    这里的 `create` 方法就属于 `createPerson` 的静态方法，并且静态成员只能在类中访问无法在实例中访问；

    上述示例等价于

    ```js learn4.js
        class CreatePerson {
            constructor(name) {
                this.name = name;
            }

            sayName () {
                console.log(this.name);
            }
            
            static create(name) {
                return new CreatePerson(name);
            }
        }

        CreatePerson.create('ceshi2').sayName(); // ceshi
    ```

    类中的所有方法和访问器属性都可以用 `static` 关键字定义，唯一的限制是不能将 `static` 用于定义构造函数方法；

******

## 继承与派生类

### ES5 中“类”的继承

```js learn05--01

    function Person(name) {
        this.name = name;
    }

    Person.prototype = {
        constructor: {
            value: Person,
            enumerable: true,
            writeable: true,
            configurable: true
        },
        sayName: function () {
            console.log(this.name);
        }
    }

    function Student(name) {
        this.job = 'student';
        Person.call(this, name);
    }

    Student.prototype = new Person();
    Student.prototype.sayJob = function () {
        console.log(this.job);
    };

    var student = new Student('xiao ming');
    student.sayName(); // xiao ming
    student.sayJob(); // student

    console.log(student instanceof Person); // true
    console.log(student instanceof Student); // true
```

******

### ES6 的类继承

```js learn05--02
    class Person1 {
        constructor(name) {
            this.name = name;
        }

        sayName() {
            console.log(this.name);
            return this.name;
        }
    }

    class Student1 extends Person1 {
        constructor(name) {
            super(name)
            // 相当于 Person1.call(this, name);
        }
        sayJob() {
            console.log('students');
        }
    }

    let student1 = new Student1('小红');

    student1.sayName(); // 小红
    student1.sayJob(); // student

    console.log(student1 instanceof Person1); // true
    console.log(student1 instanceof Student1); // true
```

可以看出类简化了继承的步骤；

`super()` 用于调用其继承对象；

继承自其他类的的类被称作为派生类，如果在派生类中指定了构造函数必须要调用 super()，否则程序将会抛出错误；如果选择**不使用构造函数，则会在创建新的类示例的时候会自动调用 super() 并且传入所有参数**

```js learn05-03

    class Student1 extends Person1 {
        constructor(name) {
            super(name)
            // 相当于 Person1.call(this, name);
        }
        sayJob() {
            console.log('students');
        }
    }

    let student1 = new Student1('小红');

    student1.sayName(); // 小红
    student1.sayJob(); // student

    console.log(student1 instanceof Person1); // true
    console.log(student1 instanceof Student1); // true

    // 相当于：

    // 03

    class Student2 extends Person1 {
        sayJob() {
            console.log('学生')
        }
    }

    let student2 = new Student2('小白');
    console.log(student2 instanceof Person1); true

```

#### 特殊的 super

1. 只可以在派生类的构造函数中使用 `super()` 
2. 在构造函数中访问 this 之前一定要调用 `super()` 因为它会初始化 `this`
3. 如果不想调用 `super()` 只能在使用 `constructor` 的时候返回一个对象

******

### 类方法的屏蔽

派生类中的方法会覆盖基类中的同名方法；

```js learn05-04
    class Student3 extends Person1 {
        constructor(name) {
            super(name)
            // 相当于 Person1.call(this, name);
        }
        sayName() {
            console.log('学生'+ this.name);
        }
        sayJob() {
            console.log('students');
        }
    }

    let student3 = new Student3('小红');

    student3.sayName(); // 学生小红
    student3.sayJob(); // student
```

在这里 Student3 中的 `sayName` 就覆盖掉了 Person1 中的同名函数；

在覆盖的过程中我们同样可以使用 `super` 来调用 Person1 的函数；

```js learn05-05
    class Student4 extends Person1 {
        constructor(name) {
            super(name)
        }
        sayName() {
            console.log('学生' + super.sayName());
        }
        sayJob() {
            console.log('students');
        }
    }

    let student4 = new Student4('小红(super)');

    student4.sayName();
    // 小红(super) -- Person 调用产出的
    // 学生小红(super) -- Student4 调用产出的

    student4.sayJob(); // student

```

> 注： 这里的 super 中的 this 将会被自动调整；

### 静态成员的继承

对于类身上的静态属性，在继承的时候回传递到其派生类身上，可以通过派生类进行调用；

```js learn05-06

    // 静态属性的继承
    // 06

    class Person3 {
        constructor(name) {
            this.name = name;
        }

        static sayJob(job, name) {
            console.log(job + ' is ' + new Person3(name).name);
        }
    }

    class Teacher extends Person3 {
        constructor(name) {
            super(name)
        }
    }

    Teacher.sayJob('Jack', 'teacher') // Jack is teacher

```

### 派生自表达式的类

只要表达式可以被解析为一个函数并且具有 `[[Construct]]` 属性和原型，那么就可以通过 `extends` 进行派生；

```js learn05-07

    // 派生自表达式的类

    // 07

    class Person4 {
        constructor (name) {
            this.name = name;
        }

        sayName () {
            console.log(this.name);
        }
    }

    function createPerson () {
        return Person4;
    }

    class ClonePerson  extends createPerson() {
        constructor (name) {
            super('clone' + name)
        }
    }

    let xiaoming = new ClonePerson('小明');
    xiaoming.sayName(); // clone小明

```

在这个示例中，`createPerson` 就是一个表达式，但是由于返回了具有 `[[Constructor]]` 的函数 -- `Person4` 所以可以通过 `extends` 生成他的派生类；

书中存在一个示例，用于生产任何组合的构造函数，挺有意思的：

```js learn05-08

    // 08

    let sayAgeMixin = {
        sayAge () {
            console.log(this.age)
        }
    }

    let sayHiMixin = {
        sayHi () {
            console.log(this.talk);
        }
    }

    function mixin (...mixin) {
        let base = function () {};
        Object.assign(base.prototype, ...mixin);
        return base;
    }

    class CreatePerson extends mixin(sayAgeMixin, sayHiMixin) {
        constructor (age, talk) {
            super();
            this.age = age;
            this.talk = talk;
        }
    }

    let person4 = new CreatePerson('24', 'hello');

    person4.sayAge(); // 24
    person4.sayHi(); // hello

```

