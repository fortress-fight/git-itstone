---
title: 迭代器与生成器
tags:
    - JavaScript
    - ES6
    - 迭代器与生成器
folder:
    - 待分类
category:
    - JavaScript
abbrlink: e9a8ddd1
date: 2018-08-07 23:39:45
---

---

<!-- more -->

## 迭代器基础

通过程序化的方式使用迭代器对象返回迭代过程中集合每一个元素，可以简化数据操作。在 ES6 中很多的特性都依赖了迭代器特性。

1.  `Set` 集合与 `Map` 集合
2.  新的 `for-of` 循环
3.  展开运算符
4.  异步编程也可以使用迭代器

-   循环语句的问题

    ```js
    var arr = ["a", "b", "c"];
    for (var i = 0, len = arr.length; i < len; i++) {
        console.log(arr[i]);
    }
    ```

    这是一段标准的 `for` 循环代码，如果将多个循环嵌套就需要跟踪多个变量。将会加大代码的复杂度。

    > 迭代器的出现就是为了消除这种复杂性并减少循环中的错误

-   迭代器

    迭代器是一个特殊的对象，包含：

    1.  `next()` 方法，每一次调用都会返回一个结果对象：`{value: 值, done: [Boolean]}`
        -   value: 表示下一个将要返回的值
        -   done: 表示是否有可返回值，如果没有更多的可返回数据就会返回 `true`;
            如果在最后一个值返回后再调用 `next()` 那么返回的 `done` 值为 `true`，`value` 将会包含迭代器最终的返回值。这个返回值不是数据集的一部分，是函数调用程序最后一次给调用者传递的值，如果不存在将会返回 `undefined`
    2.  一个内部指针，用来执行当前集合中值的位置

    我们可以通过 `ES5` 的方法创建一个迭代器

    ```js
    function createIterator(items) {
        let i = 0;
        return {
            next: function() {
                let done = i >= items.length,
                    value = !done ? items[i++] : undefined;

                return {
                    done,
                    value
                };
            }
        };
    }

    var iterator = createIterator([1, 2, 3, 4]);

    console.log(iterator.next()); // ​​​​​{ done: false, value: 1 }​​​​​;

    console.log(iterator.next()); // ​​​​{ done: false, value: 2 }​​​​​;

    console.log(iterator.next()); // ​​​​{ done: false, value: 3 }​​​​​;

    console.log(iterator.next()); // ​​​​{ done: false, value: 4 ​}​​;

    console.log(iterator.next()); // ​​​​{ done: true, value: undefined ​}​​;

    console.log(iterator.next()); // ​​​​{ done: true, value: undefined ​}​​;
    ```

    迭代器的规则比较复杂，在 ES6 中引入了生成器，可以让创建迭代器对象的过程变得简单

-   生成器

    生成器是一种返回迭代器的函数：`function* [name](){}`，函数内部包含关键字 `yield` [yield 只能在生成器中使用]；
    在对象中可以使用下面的方法创建迭代器：

    ```js
    let o = {
        *createIterator(items) {
            ...
        }
    };
    ```

    示例：

    ```js
    function* createIterator() {
        yield 1;
        yield 2;
    }

    var i2 = createIterator();

    console.log(i2.next()); // ​​​​​{ done: false, value: 1 }​​​​​;

    console.log(i2.next()); // ​​​​​{ done: false, value: 2 }​​​​​;

    console.log(i2.next()); // ​​​​​{ done: true, value: undefined }​​​​​;
    ```

    生成器特点：

    1.  每当执行完一条 `yield` 语句后，函数就会自动停止执行，直到再次调用迭代器的 `next` 方法才会继续执行
    2.  使用 `yield` 可以返回任何值或者表达式
    3.  使用 `yield` 只能在生成器中，它不能穿透函数边界也就是说，在生成器内部的函数的 `yield` 将会产生语法错误

    示例 2：

    ```js
    function* createIterator3(items) {
        for (var i = 0, len = items.length; i < len; i++) {
            yield items[i];
        }
    }

    var i3 = createIterator3([1, 2, 3]);

    console.log(i3.next());
    console.log(i3.next());
    console.log(i3.next());
    console.log(i3.next());
    ```

    > 不能使用箭头函数创建生成器

## 可迭代对象与 for-of 循环

具有 `Symbol.iterator` 属性的就是可迭代对象（生成器默认会添加，所以通过生成器创建的迭代器都是可迭代对象）； 可迭代对象是一种与迭代器密切相关的对象，`Symbol.iterator` 通过指定的函数可以返回一个作用于附属对象的迭代器；

以下对象具有默认的迭代器：

1.  数组
2.  Set 集合
3.  Map 集合
4.  字符串

for-of 循环需要用到可迭代对象的这些功能

for-of 循环没执行一次就会调用可迭代对象的 `next` 方法，并将迭代器返回的结果对象的 `value` 属性存在一个变量中。循环将持续执行这一过程直到返回的对象的 `done` 的值为 `true`。

> 相较于创痛的 for 循环，for-of 循环的控制条件更加简单，不需要追踪复杂的条件。
> 如果将 for-of 语句用于不可迭代的对象上，将会抛出错误

### 访问默认迭代器

可以通过 `Symbol.iterator` 来访问对象默认的迭代器

```js
let val = [1, 2, 3];
let i4 = val[Symbol.iterator]();
console.log(i4.next());
console.log(i4.next());
console.log(i4.next());
```

由于具有 `Symbol.iterator` 属性的对象都是默认的迭代器，所以可以通过它来检测对象是否是可迭代对象

```js
function isIterator(obj) {
    return typeof obj[Symbol.iterator] == "function";
}

console.log(isIterator([]));
```

### 创建可迭代对象

如果给对象添加一个 `Symbol.iterator` 属性，对这个属性添加一个生成器，则可以将其变为可迭代对象

```js
let collection = {
    items: [],
    *[Symbol.iterator]() {
        for (let item of this.items) {
            yield item + "：迭代";
        }
    }
};

collection.items.push(1);
collection.items.push(2);
collection.items.push(3);

for (let x of collection) {
    console.log(x);
}

// 1：迭代
// 2：迭代
// 3：迭代
```

### 转换对象为可迭代对象 (ES8)

普通对象不具有迭代器，所有不适用于 `for-of`。但是我们可以通过 `Object.entries()`/`Object.keys()`/`Object.values()` 方法将其转换成一个可迭代对象。

```js
let obj = { name: "ff", age: 24 };
console.log(Object.entries(obj));
for (const arr of Object.entries(obj)) {
    console.log(arr);
}
```

## 内建迭代器

在 ES6 中，已经为许多内建类型提供了内建迭代器。

### 集合对象迭代器

在 ES6 中有 3 中类型的集合对象：

1.  数组
2.  Map 集合
3.  Set 集合

这 3 种类型的集合对象内建三种迭代器

1.  `entries()` 返回一个迭代器，值为多个键值对

    ```js
    let ages = [10, 9, 12, 14];

    let iterator2 = ages.entries();
    console.log(iterator2.next());
    console.log(iterator2.next());
    console.log(iterator2.next());
    console.log(iterator2.next());
    console.log(iterator2.next());
    console.log(iterator2.next());
    ```

    这里我们可以看出，可以通过 `entries` 生成一个迭代器；所以我们可以通过 `for-of` 对数组进行循环；

    ```js
    let color = ["red", "blue", "origin"];
    for (const v of color.entries()) {
        console.log(v);
    }
    ```

2.  `value()` 返回一个迭代器，值为集合的值

    ```js
    let ages = [10, 9, 12, 14];

    let iterator = ages.values();
    console.log(iterator.next());
    console.log(iterator.next());
    console.log(iterator.next());
    console.log(iterator.next());
    console.log(iterator.next());
    console.log(iterator.next());

    let color = ["red", "blue", "origin"];
    for (const v of color.values()) {
        console.log(v);
    }
    ```

    > 在 Node 中执行失败

3.  `keys()` 返回一个迭代器，值为集合中的所有键名

    ```js
    let ages = [10, 9, 12, 14];

    let iterator = ages.keys();
    console.log(iterator.next());
    console.log(iterator.next());
    console.log(iterator.next());
    console.log(iterator.next());
    console.log(iterator.next());
    console.log(iterator.next());

    let color = ["red", "blue", "origin"];
    for (const v of color.keys()) {
        console.log(v); // 0 1 2
    }
    ```

不同集合类型的默认迭代器

每个集合类型都有一个默认的迭代器，在 `for-of` 循环中，如果没有显示的指定，就使用默认的迭代器；

数组和 Set 集合的默认迭代器是 `values()` 方法，Map 集合的默认迭代器是 `entries()` 方法

> 由于 WeakSet 集合和 WeakMap 集合要管理弱引用，因而无法确切地知道集合中存在的值，所有无法迭代这些集合

### 解构与 for-of 循环

我们可以使用解构语法简化编码过程：

```js
let data = new Map();

data.set("title", "ES6");
data.set("formate", "ebook");

for (const [key, val] of data) {
    console.log(key, val); // title ES6 , formate ebook
}
```

## 字符串迭代器

字符串中如果遇到双字节的，进行（for-in）循环的时候会被视为两个独立的编码单元。但是在 `for-of` 中，是操作字符而不是操作编码单元，所以可以正确输出；

## NodeList 迭代器

在 ES6 中，对 DOM 定义中的 NodeList 类型，添加了默认迭代器。其行为与数组的默认迭代器完全一致。

## 展开运算符与非数组可迭代对象

展开运算符可以操作所有可迭代对象，并根据默认迭代器来选取要引用的值，从迭代器中读取所有值，然后按照返回顺序插入到数组中：

```js
let arr = [12, 3, 4, 5];
console.log([...arr]);

let set = new Set([2, 3, 4]);
console.log([...set]);

let map = new Map([["name", "ff"], ["age", "24"]]);

console.log([...map]);

let map2 = map.keys();
console.log(map2);
console.log([...map2]);
```

在数组字面中，可以多次使用展开运算符：

```js
console.log([...arr, ...map]);
```

> 展开运算符可以适用于任何可迭代对象，如果想要将可迭代对象转换成数组，这是最简单的方式

## 高级迭代器功能

### 给迭代器传递参数

如果给迭代器的 `next()` 方法传递参数，则这个值就会替代生成器内部上一条 `yield` 语句的返回值。

```js
function* createIterator() {
    console.log("start");
    let first = yield 1;
    yield first + 2;
}

let iterator = createIterator();

// 正常
// console.log(iterator.next()) //​ ​​​​{ value: 1, done: false }​​​​​
// console.log(iterator.next()) // ​​​​​{ value: NaN, done: false }​​​​​

console.log(iterator.next()); //​​​​​ { value: 1, done: false }​​​​​
console.log(iterator.next(10)); //​​​​​ { value: 12, done: false }​​​​​
```

> 向第一个 `next` 传递的值将会被忽略
> 在执行具有 `yield` 的等式时，都会先执行 `yield` 右侧的，并在执行完后暂停，此时左侧并没有执行

### 再迭代器中抛出错误

我们可以通过使用迭代器的 `throw` 方法抛出一个错误。`throw` 和 `next` 就是迭代器的两条指令，调用 `next` 或 `throw` 都会使迭代器继续执行，但是通过 `throw` 方法，在执行之前会抛出一个错误，并且可以被迭代器内部捕获。再之后的执行过程取决于生成器内部的代码。

```js
function* createIterator2() {
    let first = yield 1;

    let second;

    try {
        second = yield first + 2;
    } catch (ex) {
        second = 10;
    }
    yield second + 10;
}

let iterator2 = createIterator2();

// console.log(iterator2.next());
// console.log(iterator2.next(2));
// console.log(iterator2.next(3));
// console.log(iterator2.next());

console.log(iterator2.next());
console.log(iterator2.next(2));
console.log(iterator2.throw(new Error("isError")));
console.log(iterator2.next());
```

### 生成器返回语句

生成器也是函数，所以可以通过 `return` 提前终止函数的执行；

```js
function* createIterator3() {
    yield "first";
    return "result";
    yield "second";
}
iterator3 = createIterator3();

console.log(iterator3.next());
console.log(iterator3.next()); // ​​​​​{ value: 'result', done: true }​​​​​
console.log(iterator3.next());

for (const v of createIterator3()) {
    console.log(v);
}
```

在使用 `next` 指令时，遇到 return 同样会暂停，并且返回 `done:true` 的对象，其 `value` 为 `return` 的返回值；

> 在执行 `return` 之后，我们依旧可以调用 `next()` 使迭代器执行，只不过后面的 yield 返回值中的 done 都为 true;
> 在 `for-of` 中使用 ，具有 return 的迭代器时，遇到 `done: true` 就会停止执行，并且忽略此时的 `value`

### 委托生成器

```js
function* createNumberIterator() {
    yield 1;
    yield 2;
}

function* createColorIterator() {
    yield "red";
    yield "green";
}

function* createCombinedIterator() {
    yield* createNumberIterator();
    yield* createColorIterator();
    yield true;
}

var iterator = createCombinedIterator();

console.log(iterator.next()); // ​​​​​{ value: 1, done: false }​​​​​
console.log(iterator.next()); // ​​​​​{ value: 2, done: false }​​​​​
console.log(iterator.next()); // ​​​​​{ value: 'red', done: false }​​​​​
console.log(iterator.next()); //​ ​​​​{ value: 'green', done: false }​​​​​
console.log(iterator.next()); // ​​​​​{ value: true, done: false }​​​​​
console.log(iterator.next()); // ​​​​​{ value: undefined, done: false }​​​​​
```

## 异步任务执行器

之前的示例中只是在多个 `yield` 调用间来回的传递静态数据，而等待一个异步数据的过程就要复杂一些，首先 yield 可以暂停函数执行，我们可以在这一阶段让其等待异步执行完毕，并在完成后执行 `next` 进入后面的执行中

```js
function run(taskDef) {
    let task = taskDef();

    let result = task.next();

    function step() {
        if (!result.done) {
            if (typeof result.value === "function") {
                result.value(function(err, data) {
                    if (err) {
                        result = task.throw(err);
                        return;
                    }

                    result = task.next(data);
                    step();
                });
            } else {
                result = task.next(result.value);
                step();
            }
        }
    }
    step();
}
```

解释： `run` 可以不断的执行迭代器的 `next` 指令直到最后一次，如果迭代器中返回的是一个函数，那么将会向这个函数里传入一个回调函数，当这个回调函数执行的才会迭代到下一个 `next` 指令。也就是说当函数在进行异步操作的时候，只有执行到回调函数时才会进行后续的操作，这样就使得异步函数可以像同步函数一样进行调用。如果有返回值，可以传入回调函数，然后传入 `next` 指令中，作为上一个 `yield` 中的返回值；

示例：

```js
import fs from "fs";

function run(taskDef) {
    let task = taskDef();

    let result = task.next();

    function step() {
        if (!result.done) {
            if (typeof result.value === "function") {
                result.value(function(err, data) {
                    if (err) {
                        result = task.throw(err);
                        return;
                    }

                    result = task.next(data);
                    step();
                });
            } else {
                result = task.next(result.value);
                step();
            }
        }
    }
    step();
}

function readFile(fileName) {
    return function(cal) {
        fs.readFile(fileName, "utf-8", cal);
    };
}

run(function*() {
    let c = yield readFile(__dirname + "/es6-iterator4.js");
    console.log(c);
});
```
