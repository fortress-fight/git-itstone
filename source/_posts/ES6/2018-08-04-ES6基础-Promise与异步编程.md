---
title: ES6基础-Promise与异步编程
tags:
    - JavaScript
    - ES6
    - Promise
folder:
    - ES6
category:
    - JavaScript
abbrlink: "89044887"
date: 2018-08-04 17:37:31
---

---

<!-- more -->

## 异步编程

异步编程是 JavaScript 中强大的功能之一，在浏览器中主要是通过事件和回调函数来响应异步的用户交互。
在 NodeJS 中，使用回调函数代替了事件。但是随着异步编程在 JavaScript 领域中更加流行，不同的异步回调已经不能满足开发者的使用。而 Promise 提供了更好的解决方案

Promise

1.  可以向事件和回调函数一样指定稍后执行的代码。
2.  可以明确指示 diam 是否成功执行，基于这些成功或者失败的状态，可以让代码更容易理解和调试
3.  可以链式编写 Promise

异步编程

1.  JavaScript 引擎是基于 **单线程** 事件循环的概念设计的，在同一时刻只允许一个代码块在执行
2.  JavaScript 引擎统一时刻只能执行一个代码，所以需要跟踪即将运行的代码，那些代码被放在一个 **任务队列** 中，每当一段代码准备执行时，就会被添加到任务代码中
3.  每当 JavaScript 引擎中的一段代码结束执行时， **事件循环** 会执行队列的下一个任务

> 事件循环是 JavaScript 引擎中的一段程序，负责监控代码执行并管理任务队列，队列中的任务会从第一个一直执行到最后一个

### 事件模型

每当用户触发 `onclick` 这样的事件，它会向事件队列中添加一个新的任务来响应用户的操作。这种异步回调会在代码执行时，添加新的任务，且执行执行上下文与定义时相同。

事件模式只是用于处理简单的交互，将多个独立的异步调用链接在一起回事程序更加复杂，因为需要跟踪每个事件的事件目标；

### 回调模式

NodeJS 通过普及回调函数来改进异步编程模式，回调模式和事件模式类似都是在未来的某个时刻执行，但是回调模式中被调用的函数是作为参数传入的；

```js
const fs = require("fs");
fs.readFile(__dirname + "/test.txt", function(err, contents) {
    if (err) {
        throw err;
    }

    console.log(contents.toString());
});

console.log("hi");
```

在 NodeJS 中，回调风格是遵循错误优先，`readFile` 函数读取磁盘上的某个文件，读取结束后执行回调函数。如果出现错误，错误对象会被赋值给回调函数的 `err` 参数，如果一切正常，文件内容会以 Buffer 字符串的形式被赋值给 `contents` 参数。

如果使用了回调模式，`readFile()` 函数立即开始执行，当读取文件时，`readFile()` 会暂停执行，当结束后会将后面的任务添加到任务队列中去。

所以上述示例中的执行顺序是：先执行 `console.log('hi')` 等待 `readFile()` 读取文件，当读取文件结束后执行函数任务

> 回调模式比事件模式更灵活

但是如果嵌套了很多的层就会形成回调地狱，是代码难以维护；如果需要实现更复杂的功能，回调函数的局限性就会显露出来：

1.  同时执行两个回调操作，需要当两个都结束时，通知你
2.  同时进行两个异步操作，只取优先完成的操作结果

使用普通的方式解决这些问题，我们需要同时跟踪多个回调函数并清理这些操作，而 Promise 就是可以更好的改进这种情况

## Promise

Promise 相当于异步操作的一个占位符，它不会订阅一个事件，依然不会传递一个回调函数给目标函数，而是让函数返回一个 Promise：

### 声明周期

每个 Promise 都会经历一个短暂的生命周期：

1.  进行中
    此时操作并未处理
2.  已处理
    操作结束后， Promise 可能会进入到两种状态；
    -   `Fulfilled` -- Promise 异步操作成功完成，
    -   `Rejected` -- 由于程序错误或者一些其他原因，Promise 异步操作未能成功执行

内部属性 `[[PromiseState]]` 用来表示 Promise 的 3 中状态：`pending`、`fulfilled`、`rejected`；这个属性并不暴露在 Promise 对象上，只能通过 `then()` 方式来采取特定的行动；

所有 Promise 都有 `then` 和 `catch` 方法；

`then` 接受两个参数：

1.  Promise 的状态变为 `fulfilled` 的时候需要调用的函数
2.  Promise 的状态变为 `rejected` 的时候需要调用的函数

> 如果一个对象实现了上述 `then` 的方法，那边这个对象就是 `thenable` 对象，所有的 Promise 都是 `thenable` 对象。

`catch` 相当于只给其传入的拒绝处理程序的 `then` 方法，能够捕获到 Promise 以及链式 Promise 中的错误，

`then` 方法和 `catch` 方法一起使用才能更好的处理异步操作结果，在 Promise 中如果没有添加拒绝处理程序，那么所有的失败就自动忽略了，所以一定要添加拒绝处理程序；

示例:

```js
const fs = require("fs");
fs.readFile(__dirname + "/test.txt", function(err, contents) {
    if (err) {
        throw err;
    }

    console.log(contents.toString());
});

console.log("hi");

let promise = new Promise((resolve, reject) => {
    fs.readFile(__dirname + "/test.txt", (err, contents) => {
        if (err) {
            reject(err);
        }
        resolve(contents);
    });
});

promise.then(
    function(contents) {
        console.log(contents.toString());
    },
    err => {
        console.log(err);
    }
);
// 等价于
promise
    .then(function(contents) {
        console.log(contents.toString());
    })
    .catch(err => {
        console.log(err);
    });
```

如果一个 Promise 处于已处理的状态，那么在这之后添加到任务队列中的处理程序仍将执行

示例：

```js
promise = new Promise((resolve, reject) => {
    fs.readFile(__dirname + "/test.txt", (err, contents) => {
        if (err) {
            reject(err);
        }
        resolve(contents);
    });
});

promise.then(function(contents) {
    console.log(contents.toString());
    promise.then(function(contents) {
        console.log(contents.toString());
    });
});
```

这里虽然，promise 在第一次执行 `then` 的时候，就已经变成了已处理的状态了，但是在第二次执行 `then` 的时候，依旧可以执行完成处理程序；

> 每次调用 `then()` 的方法或者 `catch()` 方法都会创建一个新的任务，当 Promise 被解决时执行，这些任务最终会被加入到一个为 Promise 量身定制的独立队列中

### 创建未完成的 Promise

我们可以通过 `new Promise()` 来构建新的 Promise

示例：

```js
function readFile(filename) {
    return new Promise((resolve, reject) => {
        fs.readFile(
            filename,
            {
                encoding: "utf-8"
            },
            (err, contents) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(contents);
            }
        );
    });
}

promise = readFile(__dirname + "/test.txt");

promise.then(
    contents => {
        console.log(contents);
    },
    err => {
        throw err;
    }
);
```

当 `readFile` 方法被调用的时候，执行器会立即执行。在执行器中，无论是调用 `resolve` 还是 `reject` 都会想任务队列中添加一个任务来解决这个 Promise，并且明确指定将任务延后执行。

```js
promise = new Promise((resolve, reject) => {
    console.log("Promise");
    resolve();
});

promise.then(() => {
    console.log("Resolved");
});

console.log("hi");
```

这段代码输出：

```bash
Promise
hi
Resolved
```

> 既是在代码中 `then` 调用位于 `console.log('hi')` 之前，但是传入的函数并没有立即执行，而是等待执行器完成后被添加到任务队列的末尾

### 创建已处理的 Promise

如果需要用 Promise 来表示一个已知值，可以使用特定方法创建已解决的 Promise

1.  `Promise.resolve`

此方法只接受一个参数并返回一个完成态的 Promise，示例：

```js
let promise = Promise.resolve("已知条件");

promise.then(prom => {
    console.log(prom);
});

console.log("Hi");

/**
 * 输出：
 * Hi
 * 已知条件
 */
```

2.  `Promise.reject`

此方法只接受一个参数并返回一个拒绝态的 Promise，示例：

```js
promise = Promise.reject("已经拒绝");

promise.catch(error => {
    console.log(error);
});
```

> 如果向 `Promise.resolve` 方法和 `Promise.reject` 方法传入一个 Promise，那么这个 Promise 将会立即返回

### 非 Promise 的 Thenable 对象

定义：拥有 `then` 方法并且接受 `resolve` 和 `reject` 这两个参数的普通对象；

如果向 `Promise.resolve` 方法和 `Promise.reject` 方法传入一个非 Promise 的 Thenable 对象作为参数。则这些方法会创建一个新的 Promise，并在 `then` 函数中调用；

例如：

```js
promise = Promise.reject("已经拒绝");

promise.catch(error => {
    console.log(error);
});

let thenable = {
    then(resolve, reject) {
        resolve("已解决");
    }
};

let p1 = Promise.resolve(thenable);

p1.then(val => {
    console.log(val);
});
```

在上述示例中：`Promise.resolve()` 调用的 `thenable.then()` 所以 Promise 的状态可以被检测到，此时 Promise 的状态为 `resolve` ，然后执行 `p1.then`

对于 `Promise.reject()` 同理

> 有了 `Promise.resolve` 和 `Promise.reject` 我们可以更加轻松的处理非 `Promise` 对象

### 执行器错误

如果执行器内部抛出一个错误，则 Promise 的拒绝程序就会被执行；

```js
promise = new Promise(function(resolve, reject) {
    throw new Error("explosion");
});

promise.catch(error => {
    console.log(error);
});

// 等价于

promise = new Promise(function(res, rej) {
    try {
        throw new Error("Explosion!");
    } catch (ex) {
        rej(ex);
    }
});

promise.catch(error => {
    console.log(error);
});
```

执行器会捕获所有的抛出的错误，但只有拒绝处理程序在，才会记录执行器中抛出的错误，否则将不发生任何事情；后来 JavaScript 环境提供了一些捕获已拒绝的 `Promise` 的钩子函数来解决这个问题

## 全局的 Promise 拒绝程序

如果在没有拒绝处理程序的情况下拒绝一个 Promise，那么就不会是失败信息，这就是 JavaScript 语言中唯一一处没有强制报错的点。

但是 Promise 的特性决定很难检测一个 Promise 是否被处理过；但是在 Node 和 浏览器环境中都已做出了一些改变来解决这个为；这个改变不是 ECMAScript 6 标准的一部分。下面进行简单的介绍：

> 虽然在 NodeJS 中以及浏览器中都提供了方法，但是我们最好还是显示的添加拒绝处理程序；

### NodeJS 环境的拒绝处理

在 NodeJS 中，处理 Promise 拒绝时，会触发 process 对象上的两个事件：

1.  unhandledRejection -- 在一个事件循环中，当 Promise 被拒绝，但是没有提供拒绝处理程序时被调用
    接受两个参数：1. 错误对象 2. Promise
2.  rejectionHandled -- 在一个事件循环后，当 Promise 被拒绝的时候，并没有提供拒绝处理程序时被调用
    接受一个参数：被拒绝的 Promise

这两个事件用来识别哪些被拒绝但是有没有被处理的 Promise 的；

### 浏览器环境的拒绝处理

浏览器也是通过触发两个事件来识别未处理的拒绝的，这些事件是在 Window 对象上触发的；

1.  unhandledreject
    接受三个参数：1. type - 事件名称 2. promise - 被拒绝的 Promise 对象 3. reason - 拒绝的原因
2.  rejectionhandled

这两个事件和 NodeJS 中是等价的

## 串联 Promise

可以通过将多个 Promise 串联起来实现更复杂的异步特性的方法；

每次调用 `then` 方法或 `catch` 方法时，实际上创建并返回另一个 Promise，只有当第一个 Promise 完成或被拒绝后，第二个才会被解决；

示例：

```js
let p1 = new Promise((resolve, reject) => {
    resolve("success");
});

p1.then(content => {
    console.log(content);
}).then(content => {
    console.log(content); // undefined
    console.log("Finished");
});
```

在调用 `p1.then()` 后返回第二个 Promise，紧接着又调用它的 `then` 方法；只有第一个 Promise 被解决后才会调用第二个 `then` 方法的完成处理程序

### 捕获错误

在串联的 Promise 中，任何一个环境都有可以出现错误，在 Promise 链中我们可以通过 `catch` 来捕获错误；

示例：

```js
let p2 = new Promise((resolve, reject) => {
    resolve("right");
});

p2.then(() => {
    throw new Error("this is a error");
}).catch(err => {
    console.log(err);
});
```

### Promise 链的返回值

Promise 链的可以给下游的 Promise 传递数据；如果在完成处理程序中指定一个返回值，那么就可以沿着这条 Promise 链继续传递数据：

```js
let p3 = new Promise((resolve, reject) => {
    resolve("right");
});

p3.then(infor => {
    console.log(infor);
    return "Infor is " + infor;
}).then(secInfor => {
    console.log(secInfor); // Infor is right
});
```

对于错误处理程序亦是如此

### 在 Promise 链中返回 Promise

在 Promise 间可以通过完成和拒绝处理程序中返回的原始值来传递数据，但是如果返回的是 Promise，会通过根据这个 Promise 的状态来确定下一步怎么走;

```js
let p12 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve("res");
    });
});

p12.then(res => {
    console.log(res);
    return new Promise((res, err) => {
        res("then");
    }, 1000);
}).then(res => {
    console.log(res);
});
```

## 响应多个 Promise

我们可以通过 `promise.all` 和 `promise.race` 两个方法来监听多个 Promise

### `promise.all`

`promise.all` 方法只接受一个参数：含有多个受监视 Promise 的可迭代对象，只有可迭代对象中所有的 Promise 执行完成后，该 Promise 才会被执行；并返回一个 Promise；

```js
let p4 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve(1);
    }, 1000);
});
let p5 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve(2);
    }, 2000);
});
let p6 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve(3);
    }, 3000);
});

let p7 = Promise.all([p4, p5, p6]);
console.log(new Date());

p7.then(content => {
    console.log(content);
    console.log(new Date());
});
```

> 如果在传入 `Promise.all` 方法中的 Promise 只要有一个拒绝，那么将会返回的 Promise 就会立即被拒绝

### `Promise.race`

`Promise.race` 方法接受多个受监视 Promise 的可迭代的对象，作为唯一参数，并返回一个 Promise，但是只要有个 Promise 被解决返回的 Promise 就会被解决。

```js
let p8 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve(1);
    }, 1000);
});
let p9 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve(2);
    }, 500);
});
let p10 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve(3);
    }, 3000);
});

let p11 = Promise.race([p8, p9, p10]);
console.log(new Date());

p11.then(content => {
    console.log(content);
    console.log(new Date());
});
```

> 如果在传入 `Promise.race` 方法中的 Promise 只要有一个拒绝，那么将会返回的 Promise 就会立即被拒绝

## 基于 Promise 的异步任务执行

{% post_link 2018-08-07-迭代器与生成器 %} 中的末尾介绍了生成器在在不任务执行中的使用；但是这里会存在一些问题：

-   每一个执行的回调函数需要包裹两层使用，不易理解
-   无法区分用作任务执行器的回调函数的返回值和一个不是回调函数的返回值

我们可以通过将每一个回调操作都返回 Promise 的方式，简化并通用这个过程

```js
function run(taskDef) {
    let task = taskDef();

    let result = task.next();

    (function step() {
        if (!result.done) {
            let promise = Promise.resolve(result.value);

            promise
                .then(value => {
                    result = task.next(value);
                    step();
                })
                .catch(error => {
                    result = task.throw(error);
                    step();
                });
        }
    })();
}
```

示例：

```js
import fs from "fs";

function run(taskDef) {
    let task = taskDef();

    let result = task.next();

    (function step() {
        if (!result.done) {
            let promise = Promise.resolve(result.value);

            promise
                .then(value => {
                    result = task.next(value);
                    step();
                })
                .catch(error => {
                    result = task.throw(error);
                    step();
                });
        }
    })();
}

function readFile(filename) {
    return new Promise((res, rej) => {
        fs.readFile(filename, "utf-8", (err, con) => {
            if (err) {
                rej(err);
            } else {
                res(con);
            }
        });
    });
}

run(function*() {
    let con = yield readFile(__dirname + "/test.txt");
    console.log(con);
});
```

## ES8 -- async

`async function` 声明将定义一个返回 `AsyncFunction` 对象的异步函数。异步函数是指通过事件循环异步执行的函数，它会通过一个隐式的 Promise 返回其结果。但是如果你的代码使用了异步函数，它的语法和结构会更像是标准的同步函数。

```js
async function name([param[, param[, ... param]]]) { statements }
```

当调用一个 `async` 函数时，会返回一个 `Promise` 对象。当这个 `async` 函数返回一个值时，`Promise` 的 `resolve` 方法会负责传递这个值；当 `async` 函数抛出异常时，`Promise` 的 `reject` 方法也会传递这个异常值。

```js
async function getPromise(param) {
    return "answer" + param;
}

let promise1 = getPromise("is not good");
promise1.then(res => {
    console.log(res);
});
```

`async` 函数中可能会有 `await` 表达式，这会使 `async` 函数暂停执行，等待表达式中的 `Promise` 解析完成后继续执行 `async` 函数并返回解决结果。

> await 关键字仅仅在 async function 中有效。如果在 async function 函数体外使用 await ，你只会得到一个语法错误（SyntaxError）。

```js
async function getFile(filename) {
    let con = await getFileContent(filename);
    console.log(con); // this is a file
}

function getFileContent(filename) {
    return new Promise((res, rej) => {
        fs.readFile(filename, "utf-8", (err, con) => {
            if (err) {
                rej(err);
                return;
            }
            res(con);
        });
    });
}
getFile(__dirname + "/test.txt");
```

## 总结

Promise 的设计目标是改进 JavaScript 中的异步编程，它能让你更好的掌控并组合多个同步操作，是事件系统和回调更加实用。Promise 编排的任务会被添加到 JavaScript 引擎任务队列并在未来执行，还有个任务队列用于跟踪 Promise 的完成处理程序和拒绝处理城区并确保正确执行
