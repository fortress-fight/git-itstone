---
title: ES6基础-扩展对象的功能性
folder:
  - 待分类
abbrlink: 35ba46cd
date: 2018-01-08 23:37:04
tags:
photos: ./xmind/ES6/ES6基础-对象.png
---

******

<!-- more -->

{% img /xmind/ES6/ES6基础-对象.detail.png %}

******

# ES6 基础 - 对象的扩展

ES6 中通过多种方法来加强对象的使用，通过简单的语法扩展提升了对象的使用效率

## 对象类别

在浏览器中，对象没有统一的标准；在 ES6 的对象中清洗定义了每一个类别的对象，具体如下：

1. 普通对象 具有 JavaScript 对象的所有默认行为
2. 特异对象 具有部分与默认行为不符的内部变量
3. 标准对象 ES6 规范中定义的对象
4. 内建对象 脚本开始执行时就存在于 JavaScript 执行环境中的对象，所有的标准对象都是内建对象；

******

## 增强对象方法

### 对象字面量语法的扩展

1. 属性初始值的简写

    ES6 中规定：当一个对象的属性和本地变量名相同时，不必再写冒号和值，只需要简写个属性名就可以。
	
	```js
		let name = 'example';
		var obj = {
			name,
		}
		// 相当于
		var obj = {
			name: name
		}
	```

	当对象字面量中只有一个属性名时，JavaScript 引擎会自动在可访问的作用域中查找其同名变量

2. 对象方法的简写语法

	在 ES6 中，对象方法消除了冒号和 function 关键字

	```js
		let obj = {
			name: 'example',
			say () {
				console.log(this.name);
			}
		};

		// 相当于

		let obj = {
			name: 'example',
			say: function () {
				console.log(this.name);
			}
		};
	```

	{% blockquote %}
		通过对象方法简写语法创建的方法有个 `name` 属性，其值为小括号前的名称
	{% endblockquote %}

3. 可计算属性名

	在 ES6 中可以使用可计算属性名称，其语法与引用对象示例的可计算属性名称相同，也是使用方括号

	```js
		let lastName = "last name";
		let person = {
			[lastName]: "zakas"
		};
		// 相当于
		let lastName = "last name";
		let person = {};
		person[lastName]: "zakas";
	```

### 新增方法

**ECMAScript 其中一个设计目标是：不再创建新的全局函数，也不再 `Object.prototype` 上创建新的方法**

在 ES6 中对 Object 对象上引入了一些新的方法

1. Object.is()

	ES6 引入了 `Object.is()` 方法来弥补全等运算符的不准确运算的情况

	例如：

	```js
		console.log(+0 === -0) // true
		console.log(NaN === NaN) // false
	```

	通常我们会认为 `+0` 和 `-0` 应该是不同的；而 `NaN` 可以等于 `NaN` 而不是值通过 `isNaN()` 来进行判断，这时我们可以通过使用 `Object.is()` 的方式来进行判断两个值是否相同；对于其它情况 `Object.is()` 和 `===` 标签表现一致

	```js
		console.log(Object.is(+0, -0)); // false
		console.log(Object.is(NaN, NaN)); // true
	```

2. Object.assign()

	我们常常面对一个需求：从一个对象上接收来自另一个对象的属性和方法

	```js learn01.js
		function mixin (receiver, supplier) {
			Object.keys(supplier).forEach(function (key) {
				receiver[key] = supplier[key];
			});
			return receiver;
		}

		let example = {
			name: 'example',
			age: '24'
		};

		let person = {};

		mixin(person, example);
		console.log(person); // { name: 'example', age: '24' }
	```

	我们可以看到这里是一个简单的潜复制方法，ES6 中提供了一个方法来实现：

	```js learn02.js				
		let person2 = {};
		Object.assign(person2, example);
		console.log(person2); // { name: 'example', age: '24' }
	```

	{% blockquote %}
		由于 `Object.assign` 方法指向了赋值操作，因此不能将提供者的访问器属性复制到接受对象中，
	{% endblockquote %}

******

## 对象的扩展

原型是 JavaScript 集成的基础，在 ES6 中对原型进行了改进，让开发者能够获得更多对于原型的控制力；

### 改变对象的原型

正常情况下，通过构造函数还是 `Object.create()` 方法创建的对象，对象原型在实例化之后将会保持不变，在 ES5 中添加了 `Object.getPrototypeOf()` 方法来返回指定对象的原型，但是缺少对象在实例化后改变原型的方法；在 ES6 中添加了 `Object.setPrototypeOf()` 方法来改变这个现状，通过这个方法可以改变任意指定对象的原型；

> Object.create() 方法会使用指定的原型对象及其属性去创建一个新的对象: 具体可以查看 [Object.create()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create)

```js learn01.js
	let person = {
		getGreeting () {
			return 'Hello';
		}
	}

	let dog = {
		getGreeting () {
			return 'wangwang'
		}
	}

	let person1 = Object.create(person);
	console.log(Object.getPrototypeOf(person1) === person); // true

	// 这里我们将 person1 的原型修改到 dog 上

	Object.setPrototypeOf(person1, dog);
	console.log(person1.getGreeting()); // wangwang
	console.log(Object.getPrototypeOf(person1) === dog) // true
```

对象原型的真实值被储存在内部专用属性 `[[Prototype]]` 中，调用 `Object.getPrototypeOf()` 返回其中的值，调用 `Object.setPrototypeOf()` 方法可以修改这里面的值

### 简化原型访问的 Super 引用

使用 Super 可以更加便捷的访问对象原型；

需求：如果需要针对当前对象重写对象实例的方法，但是用需要调用与它同名的原型方法

```js learn01.js
	// 03
	let person = {
		getGreeting() {
			return 'Hello';
		},

		say: () => {
			console.log(this);
		}
	};

	let dog = {
		getGreeting () {
			return 'wangwang';
		}
	};

	// 需求：创建一个新的对象，对象中可以使用其原型上的 getGreeting 的方法，并添加 friend 的标识

	let friend = {
		getGreeting () {
			return Object.getPrototypeOf(this).getGreeting.call(this) + ' friend';
		}
	}

	Object.setPrototypeOf(friend, person);
	console.log(friend.getGreeting()) // Hello friend

	// 修改 friend 的原型

	Object.setPrototypeOf(friend, dog);
	console.log(friend.getGreeting()); // wangwang friend
```

为了更加方便的调用其原型的上的方面， ES6 中引入了 super 关键字

```js learn01.js
	// 04
	let person = {
		getGreeting() {
			return 'Hello';
		},

		say: () => {
			console.log(this);
		}
	};

	let dog = {
		getGreeting () {
			return 'wangwang';
		}
	};

	// 需求：创建一个新的对象，对象中可以使用其原型上的 getGreeting 的方法，并添加 friend 的标识

	let friend = {
		getGreeting () {
			return super.getGreeting() + ' friend';
		}
	}

	Object.setPrototypeOf(friend, person);
	console.log(friend.getGreeting()) // Hello friend

	// 修改 friend 的原型

	Object.setPrototypeOf(friend, dog);
	console.log(friend.getGreeting()); // wangwang friend
```

super 其实引用了相当于指向对象原型的指针，也就是 `Object.getPrototypeOf` 的值，并且可以避免 `Object.getPrototypeOf(this)` 中 this 指向错误的问题；

> super 必须在使用简写方法的对象中使用 super 引用，否则会引起语法错误；

### 正式的方法定义

以前方法仅仅是一个功能而非数据的对象属性，在 ES6 中正式将其定义为一个函数；它将会存在一个内部的 `[[HomeObject]]` 属性来容纳这个方法从属的对象；

```js
	let person = {
		// 方法
		getGreenting () {
			return 'Hello'
		}
	};

	// 不是方法
	function shareGreeting () {
		return "hi";
	}
```

在 person 对象中的 `getGreeting` 方法中具有 `[[HomeObject]]` 属性，其值为 `person`;
这个属性主要用于配合 Super 使用，来确定其调用函数时的执行上下文；

super 的所有引用都通过 `[[HomeObject]]` 的属性来确定后续的运行过程，第一步是在 `[[HomeObject]]` 属性上调用 `Object.getPrototypeOf()` 方法检测原型的原型的引用，然后找到同名函数，并将 `[[HomeObject]]` 绑定并且调用相应的方法；

******

## 其它

### 重复的对象字面量属性

在 ES5 中的严格模式下，一个对象下出现名属性将会引起错误，而在 ES6 中取消了重复属性的检查，所以即使出现了重复属性也不会发生错误；

### 自有属性枚举顺序

在 ES5 中，对于对象的枚举是不存在规定的顺序的，而是由 JavaScript 引擎厂商自由决定；在 ES6 中严格的规定了对象的自有属性被枚举时的访问顺序；

具体遵循以下规则：

1. 所有数字键安升序排序
2. 所有字符键安装它们被加入对象的顺序排序
3. 所有 symbol 键，安照它们被加入的对象的顺序排序
4. 字符键在数字键后

目前该规则印象的方法有：`Object.getOwnPropertyNames()` `Object.assign()` 以及 `Reflect.ownKeys` 而对于 `for-in` 的循环方式并不生效；`for-in` 循环的枚举顺序，是由厂商规定，没有明确的规则限定，我们常使用的 `Object.keys()` 以及 `JSON.stringify()` 则指明与 `for-in` 使用相同的循环方式；
