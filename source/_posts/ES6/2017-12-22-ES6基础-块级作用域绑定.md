---
title: ES6基础 块级作用域绑定
tags:
  - javascript
  - es6
  - 前端
categories:
  - ECMAScript6
folder: es6
abbrlink: 8af4f2ba
photos: /xmind/ES6/块级作用域.png
date: 2017-12-22 23:25:34
---


******

<!-- more -->

# ES6 -- 块级作用域

## ES5 的变量声明

在 ES5 中，我们可以通过 `var` 和 `function` 进行变量声明；其中最大的特点就是变量提升机制

```js
    console.log(simple); // simple is not defined
    var simple = 'hello';
    // 这里 var simple = 'hello' 其实是两部执行，1 var simple 2 simple = 'hello' 其中 var simple 会在预编译阶段被提升到当前作用域顶部执行

    console.log(fn); // [Function: fn]
    function fn () {};
```

这种变量提升的机制，容易让人产生困惑；在 ES6 中 提供了块级作用域的概念，以及 `let` & `const` 两个**块级标识符**

******

## Var、Let 和 Const

在 JS 中，我们通常通过 `var` 声明一个变量，现在 ES6 为我们提供了新的选择 -- `let` 和 `const`；其中 `var` 最为随意 `const` 最为严格；

> ES6 下声明变量的方式有：`var` `function` `let` `const` `class`

### 基本概念

我们可以通过下面几个方面对这三个方法进行比较；

1. 基本用法
    `var`/`let`/`const` 的基本用法相同，声明一个变量:

    ```js
        var <变量名>;
        let <变量名>;
        const <变量名> = <变量值>;
    ```

    不同点：

    - `const` 声明变量的方式最为严格，一旦声明后，就不能对其再次赋值，所以在初始化的时候就要对其赋值，否则会抛出错误；而 `let` 和 `var` 可以在声明的同时对其赋值，也可以在之后对其赋值；
    - `const` 和 `let` 都不允许对一个已近被赋值的变量重复赋值，而 `var` 可以

    ```js learn01-02
        // let sample02 = "sample02";
        // let sample02 = "error"; // Identifier 'sample02' has already been declared

        // const sample02 = "sample02";
        // const sample02 = "error"; // Identifier 'sample02' has already been declared

        // const sample02; // Missing initializer in const declaration
    ```

2. 变量提升
    `var` 声明变量时，最大的一个特点就是变量提升，而 `const` 和 `let` 都不存在变量提升，在其声明之前使用，会直接抛出错误；

    ```js learn01-03
        // console.log(sample3); // undefined
        // var sample3 = 'sample03'; 

        // console.log(sample3); // sample3 is not defined;
        // let sample3 = 'sample03'; 

        // console.log(sample3); // sample3 is not defined;
        // const sample3 = 'sample03'; 
    ```

    可以看出 `var` 由于变量提升，所以在 console.log 的时候是定义未赋值的状态，而 对于 `const`/`let` 缺失未定义的状态；

3. 全局对象的属性
    全局对象是最顶层的对象，在浏览器下全局对象是 `window` 在 Node 下全局对象是 `global`;
    在 ES5 中，全局对象的属性和全局变量是等价的，通过 `var` 或者 `function` 在全局作用域下声明的全局变量就会影响到全局对象的属性
    而在 ES6 中，通过 `const || let` 在声明的全局变量，就不会影响到全局对象的属性

### 特殊的 const

我们可以看到 `const` 算是一个十分严谨的变量声明方式了，但是如果对变量赋值的是一个对象，那么 const 只能做到不让这个对象的地址发生变化，而这个对象内发生了变化，const 将无法限制；

```js learn01-6
    const simple6 = {
        name: 'const'
    };

    simple6.name = "constchange";
    simple6.val = "simple6";
    console.log(simple6); // { name: 'constchange', val: 'simple6' }
```

{% blockquote %}

    如果真想冻结一个变量，可以使用 `Object.freeze` (只能冻结一级)
    `Object.freeze(object);`
{% endblockquote %}

### 块级作用域

问题1：一个变量如果才能不污染全局作用域 ？

通常我们会有这样的需求：希望这个变量只在某个区域起作用，而不污染外部区域；这样我们通过借助函数来实现局部作用域，例如：

```js learn01-01
    var space = 'global';
    (function {
        var space = 'function';
        console.log(space) // function
    })();
    console.log(space) // global
```

这样我们就可以做到函数内部的变量不去污染外部的作用域；在 ES6 里我们有了更加便捷的方式实现 -- 代码块
**在 ES6 中规定在 `{}` 中间的区域为一个块级域**

### 块级作用域对变量声明的影响

1. var 
    块级作用域对 `var` 声明变量的方式，没有任何影响；并不能阻止变量的提升， 也不能阻止外部作用域对其的访问；

    ```js
        console.log(sample4); // undefind
        {
            var sample4 = "sample4";
        }
        console.log(sample4) // sample4
    ```

2. let & const
    let & const 在块级作用域下具有相同的表现，具体表现如下：

    - 仅在当前作用域中生效，一旦执行到当前块级作用域外，就会立即销毁
    - 阻止外部作用域访问 `let` & `const` 在块级作用域内部声明的变量；
    - 暂存死区（TDZ）
        -- 只要在块级作用域内存在 `let` & `const` 命令，其声明的变量将会绑定到当前作用域上，不再受外部影响；

        在预编译阶段，编译器对于 `var` 声明的变量会进行变量提升，而对于 `let` 和 `const` 两个块级标识符声明的变量就会存放在当前块级域下的**暂存死区**中，知道变量进行声明后才会从暂存死区中取出，放入块级作用域中；在这之前任何对暂存死区的访问都将触发运行错误；

        虽然 ECMAScript 中并没有明确暂存死区的存在，但是我们通过使用这个名词来对变量不提升进行描述

        ```js learn01-05
            let simple5 = 'simple00';
            {
                console.log(simple5); // simple5 is not defined
                let simple5 = 'simple5';
            }
            // 执行到 console.log(sunoke5) 的时候， 系统向其所在的块级作用域查找 simple5 ，
            // 但是系统查找到 let simple5 告诉系统 simple5 我已经预定了，如果你要找就不要向外面查了，
        ```

3. function
    函数本身的作用域同样会受到块级作用域的影响；
    在严格模式下，函数只能在顶层作用域下或者函数作用域下进行声明，在 `for` / `if` 语句下进行声明，将会抛出错误

******

## 示例

1. for 循环中的块级作用域

    ```js learn01-07
        for (var i = 0; i < 6; i++) {
            setTimeout(function () {
                console.log(i) // 6 6 6 6 6 6
            });
        }
    ```

    这里存在一个常见问题，当函数执行的时候，`for` 循环依然执行结束，函数内部变量，查找 `i` 时，会从全局中找到，这是 `i` 已然是 6；

    方法1：

    ```js learn01-07
        for (var i = 0; i < 6; i++) {
            (function (j) {
                setTimeout (function () {
                    console.log(j) // 0 1 2 3 4 5
                })
            })(i);
        }
    ```

    方法2：

    ```js learn01-07
        for (let i = 0; i < 6; i++) {
            setTimeout (function () {
                console.log(i) // 0 1 2 3 4 5
            });
        }
    ```

    这里利用了块级作用域配合 `let` 实现，变量使用 `let` 声明，每次循环的使用，循环体就会绑定当前的 `i` ，所以每一次循环的 `i` 其实都是一个新的变量；并且循环外部访问不到循环内使用 `let` 声明的变量；其实这里并不是通过 `let` 特性来实现的，而是 ECMAScript 特意规定的行为（`const` 并不能通过这种方式实现相同功能）； 真正在循环中绑定的方式是在 `for-in` 以及 `each` 中实现的；

******

{% img '/xmind/ES6/块级作用域.detail.png' %}

******

{% blockquote %}

## Tip

    1. 建议：尽可能的使用 `const` 去声明变量，遇到需要发生变化的变量再使用 `let` ，尽量不去使用 `var`。这样做可以规范代码，减少不规范的声明方式产生的问题；

{% endblockquote %}
