---
title: vue代码段
tags:
    - vue
    - 代码段
categories:
    - - vue
abbrlink: 9a7f1f9f
date: 2020-08-06 22:31:18
---

{% note default %}

-   Vue hook
-   Vue 依赖注入
-   Vue EventBus

{% endnote %}

<!-- more -->

---

## Vue hook

版本：`vue@^2.6.10`
介绍：[程序化的事件侦听器](https://cn.vuejs.org/v2/guide/components-edge-cases.html#%E7%A8%8B%E5%BA%8F%E5%8C%96%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BE%A6%E5%90%AC%E5%99%A8) 在 vue 文档中，只是在事件监听的中对于 hook 的使用简单的提了一句，不过其还是十分有用的。

使用：

    ```js
    // 监控声明周期钩子使得更易阻止代码
    this.$once("hook:beforeDestroy", function () {});
    ```

## Vue 依赖注入

版本：`vue@^2.6.10`
介绍：[依赖注入](https://cn.vuejs.org/v2/guide/components-edge-cases.html#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5) 依赖注入可以指定数据/方法将其提供给所有的后代组件

-   优点：后代元素都可以使用父级注入的属性和方法
-   缺点：
    1.  父级组件将会和后代组件强耦合
    2.  后代组件不知道使用的属性或方法来自哪个父级组件

使用：

    ```js
    // 父级组件定义 provide
    provide: function () {
        return {
            getMap: this.getMap
        }
    }
    ```

    ```js
    // 后代组件定义 inject
    inject: ['getMap']
    ```

补充:

-   provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。
-   可以将 inject 的值，用于 props 和 data

    ```js
    const Child = {
        inject: ["foo"],
        props: {
            bar: {
                default() {
                    return this.foo;
                },
            },
        },
    };
    ```

-   可以对 inject 的值使其变成可选项

    ```js
    const Child = {
        inject: {
            foo: { default: "foo" },
        },
    };
    ```

-   如果它需要从一个不同名字的 property 注入，则使用 from 来表示其源 property

    ```js
    const Child = {
        inject: {
            foo: {
                from: "bar",
                default: "foo",
            },
        },
    };
    ```

## Vue EventBus

vue 中事件的传递

```js
export function broadcast(component: any, componentName: string, eventName: string, params) {
    // debugger;
    component.$children.forEach((child) => {
        var name = child.$options.componentName;
        if (componentName) {
            if (name === componentName && child[eventName]) {
                child[eventName].apply(child, params);
            } else {
                broadcast.apply(child, [child, componentName, eventName, params]);
            }
        } else {
            if (child[eventName]) {
                child[eventName].apply(child, params);
            }
            broadcast.apply(child, [child, componentName, eventName, params]);
        }
    });
}
export function dispatch(component, componentName, eventName, params = []) {
    var parent = component.$parent || component.$root;
    var name = parent.$options.componentName;
    while (parent && (!name || name !== componentName)) {
        parent = parent.$parent;

        if (parent) {
            name = parent.$options.componentName;
        }
    }
    if (parent) {
        parent.$emit.apply(parent, [eventName].concat(params));
    }
}
```
