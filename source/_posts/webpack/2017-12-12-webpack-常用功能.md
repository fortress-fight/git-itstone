---
title: webpack-常用功能
tags:
  - webpack
  - 自动化
  - 前端
categories:
  - 自动化
  - webpack
folder: Webpack
abbrlink: 72d60d41
date: 2017-12-12 23:18:59
---


在了解了 webpack 后，我们需要使用 webpack 提高我们的工作，这时就需要使用一些插件和工具了

<!-- more -->

# Webpack

基于 webpack 3.* 的学习

## 基本部署

这里新建一个文件夹 learn02 来进行学习
目录结构如下：

```shell learn02
    .
    ├── dist
    ├── node_modules
    ├── package.json
    ├── src
    └── webpack.config.js
```

### 编写 webpack.config.js

基础代码如下：

```js webpack.config.js
    const paht = require('paht');
    module.exports = {
        entry: {
            entry: './src/entry'
        },
        output: {
            path: path.resolve(__dirname, 'dist'),
            filename: '[name].js'
        },
        module: {},
        plugins: [],
        devServer: {}
    }
```

******

## 服务与热加载

在工作环境中，我们经常是需要启动服务器环境来调试我们的页面；以前我们可以通过在本机搭建服务器环境来做到这一点，比如安装 `wamp` 或者是 `xampp`; 但是随着 node 的发展，我们已经无需繁琐的部署环境了。

### live-server

使用 [live-server](https://www.npmjs.com/package/live-server) 就可以立即在本机上启动服务；

1. `cnpm i -g live-server` 全局安装 live-server
2. 在需要启用服务的路径下输入 `live-server`

live-server 具有热更新的功能，但是对于更复杂的功能（配合 webpack 实现热更新），webpack 也具有服务插件 -- webpack-server

### webpack-server

1. 安装 webpack-server `cnpm i -D webpack-server`
2. 修改 `webpack.config.js` 文件

    在 `webpack.config.js` 中存在 `devServer` 配置项；

    ```js webpack.config.js
        ...
        devServer: {
            // 服务启动的根目录
            contentBase: path.resolve(__dirname, 'dist'),
            // server 地址，本机 IP 地址
            host: '192.168.31.104',
            // 服务器压缩
            compress: true,
            // 服务器端口
            port: 8080
        }
        ...
    ```
3. 运行
    这里需要注意，webpack-dev-sever 是安装到 node_modules 中的，如果直接通过命令行运行 `webpack-dev-server` 是无法引入 `webpack-dev-server` 插件的。需要在 Node 下运行；
    我们可以将命令写入 `package.json` 中，依靠 node 中对插件的引入方式，就可以运行了；
    修改 `package.json`:
    ```json package.json
        {
            "name": "learn02",
            "version": "1.0.0",
            "description": "",
            "main": "webpack.config.js",
            "scripts": {
                "server": "webpack-dev-server"
            },
            "author": "",
            "license": "ISC",
            "devDependencies": {
                "webpack": "^3.10.0",
                "webpack-server": "^0.1.2"
            }
        }
    ```
    然后运行 `cnpm run server` 服务启用
4. 测试
    这时我们修改 entry.js 的时候，代码会重新编译（增量编译），页面更新；

> 注意：在 webpack 3.5 之前，是不带热更新的，需要进行额外的配置

******

## CSS 文件打包

在介绍 CSS 文件打包之前，我们需要先了解 loader;

{% blockquote %}
loader 让 webpack 能够去处理那些非 JavaScript 文件，loader 可以将所有类型的文件转换成为 webpack 能够处理的有效模块，然后就可以利用 webpack 的打包能力，对它们进行处理
{% endblockquote %}

首先 webpack 本身仅仅是用于处理 JS 模块化的工具，但是如果我想使用 webpack 去处理非 JavaScript 文件怎么办，这个时候我们就需要通过 loader 将 webpack 本身不能处理的文件，转换成为 webpack 能够识别的模块；
也就是说先通过 loader 过滤入口文件，将入口文件引入的而 webpack 不能处理的文件转换成能被处理的模块，然后webpack 解析入口文件的时候，就可以将这些已经被 loader 处理过的文件，加载进来；

### loader 示例

loader 的管理是在 `webpack.config.js` 下的 module 字段下

```js webpack.config.js webpack.config.js
    ...
    module: {
        rules: [
            {
                test: /\.txt$/,
                use: 'XX-loader'
            }
        ]
    }
    ...
```

这一个字段表达的含义是：在解析入口文件的时候，如果碰到通过 `require()` 或者 import 的方式引入的文件，并且路径是满足 test 验证，文件需要使用 `XX-loader` 进行转换；

> 注意：在 webpack 配置中定义 loader 的时候，要定义在 module.rules 中

### 实现 css 文件打包

我们以 loader 的思维，思考我们如何对 css 打包；

1. 首先什么是 css 文件打包？
    在 webpack 眼中，其实只有入口的 JS 文件。所有的其他资源都是通过模块化的方式引入到入口文件中的，然后将最终的结果进行输出；
    css 文件打包，就是将 css 文件引入到入口的 JS 文件中使用，最终输出带有 css 文件内容 JS 的输出文件；

2. 为什么要对 css 文件进行打包？
    我们可以想到，css 文件单独引入是十分合理的行为，为什么要引入到 JS 中。其实还是 webpack 只能看到 JS 文件的原因。如果 css 不引入到 JS 中，或者说 css 不转换成能被 webpack 识别的代码。那么 webpack 就不能对其进行识别，也不能对其进行处理，这样面对 `scss` 等文件，`postcss` 等功能，webpack就没法使用；
    （个人觉得，面对这种境况 gulp 的处理方式要更合理一些）

3. 怎么做？
    使用加载所需的 loader 进行配合

打包 css 之前，我们需要解决两个问题：

1. css 的引入 使用 `css-loader` 处理。
2. css 中的 url 的处理 使用 `style-loader` 处理；

开始：

1. 新建 css 文件

    ```css
        body {
            background: #58a;
        }
    ```
    目录

    ```tree
        .
        ├── dist
        │   ├── bundle.js
        │   └── index.html
        ├── package.json
        ├── src
        │   ├── css
        │   │   └── index.css
        │   └── entry.js
        └── webpack.config.js
    ```
2. 入口文件中引入 css

    ```js javascipt src/js/entry.js
        import './css/index';
        alert('2')
    ```
3. 安装 loader `cnpm i -D style-loader css-loader`
4. 配置 `webpack.config.js`

    ```js webpack.config.js webpack.config.js
        ...
        module: {
            rules: [{
                test: /\.css$/,
                use: ['style-loader', 'css-loader']
            }]
        }
        ...
    ```
    这里需要注意了，use 是值使用什么样的 loader 对文件进行处理，可以使用多个，处理的顺序是从**右向左**，也就是说先通过 `css-loader` 加载 css，然后在通过 `style-loader` 处理 css 中的 url；
5. 运行
    
    ```shell shell
        webpack
    ```
    编译输出：
    
    ```shell shell
        Hash: 55166187b64a63e362cd
        Version: webpack 3.10.0
        Time: 602ms
            Asset    Size  Chunks             Chunk Names
        bundle.js  6.3 kB       0  [emitted]  entry
        [0] ./src/entry.js 36 bytes {0} [built]
        [1] ./src/css/index.css 1.1 kB {0} [built]
        [2] ./node_modules/_css-loader@0.28.7@css-loader!./src/css/index.css 217 bytes {0} [built]
            + 3 hidden modules
    ```

    结束后，我们可以在输出文件（bundle.js）中查看到我们的 css 代码

    ```js
        exports.push([module.i, "body {\n    background: #58a;\n}", ""]);
    ```

******

## JS 代码的压缩

实现 JS 代码压缩前，我们了解 `plugins`
loader 使用与转换某些类型的模块，而插件是用于执行范围更广的任务（主要是对输出进行操作）
要想使用一个插件： 在 `webpack.config.js` 顶部通过 `require()` 引入，然后把它添加到 `plugins` 数组中并实例化即可；

示例：

```js webpack.config.js
    const HtmlWebpackPlugin = require('html-webpack-plugin'); // 通过 npm 安装
    ...
    plugins: [
        new webpack.optimize.UglifyJsPlugin(),
        new HtmlWebpackPlugin({template: './src/index.html'})
    ]
    ...
```

> webpack.optimize.UglifyJsPlugin() 可以使用是因为 webpack 自带了一些可以直接使用的插件 [插件列表](https://doc.webpack-china.org/plugins)

### 实现 JS 文件压缩

要实现 JS 文件压缩，我们需要找到具有压缩功能的插件；这里选择使用  `uglifyjs-webpack-plugin`

1. 安装插件；`cnpm i -D uglifyjs-webpack-plugin`;
2. 配置 `webpack.config.js`

    ```js webpack.config.js
        require uglyfy = require('uglifyjs-webpack-plugin');
        ...
        plugins: [
            new uglyfy()
        ]
        ...
    ```
3. 运行

    ```shell shell
        webpack
    ```

    编译输出：
    
    ```shell shell
        Hash: 55166187b64a63e362cd
        Version: webpack 3.10.0
        Time: 602ms
            Asset    Size  Chunks             Chunk Names
        bundle.js  6.3 kB       0  [emitted]  entry
        [0] ./src/entry.js 36 bytes {0} [built]
        [1] ./src/css/index.css 1.1 kB {0} [built]
        [2] ./node_modules/_css-loader@0.28.7@css-loader!./src/css/index.css 217 bytes {0} [built]
            + 3 hidden modules
    ```

    然后观察到 `bundle.js` 已经被压缩了
4. 目录

    ```shell tree
        .
        ├── dist
        │   ├── bundle.js
        │   └── index.html
        ├── package.json
        ├── src
        │   ├── css
        │   │   └── index.css
        │   └── entry.js
        └── webpack.config.js
    ```

******

## HTML 的文件打包

前一些的示例，HTML 文件是存放在输出文件夹 dist 下的；那么我们能不能把它也进行一些处理；首先直接放到 dist 文件下是不合适的，需要放到 src 文件夹下。2. HTML 前后位置发生变化，引入路径也希望能够自动处理掉；

HTML 作为非 javascript 文件也是一个比较特殊的存在，因为它是页面的母体；尽管所有资源都可以通过 JS 引入，但是 HTML 文件，就需要单独处理；

### 实现 HTML 的文件打包

这里由于不要将 HTML 引入 JS 中，所以不需要使用 `loader` 处理，而是使用 `plugin` 处理; 选择插件 `html-webpack-plugin`

1. 目录清理

    ```shell tree
        .
        ├── package.json
        ├── src
        │   ├── css
        │   │   └── index.css
        │   └── entry.js
        └── webpack.config.js
    ```
2. 安装插件 `cnpm i -D html-webpack-plugin`
3. 修改 `webpack.config.js`

    ```js webpack.config.js webpack.config.js
        const htmlplugin = require('html-webpack-plugin');
        ...
        plugins: [
            new uglyfy(),
            new htmlplugin({
                // 压缩
                minify: {
                    // 去除属性的双引号
                    removeAttributeQuotes: true
                },
                // hash 后缀
                hash: true,
                // 以哪个为模板进行加载
                template: './src/index.html'
            })
        ],
    ```
    这里使用了 `html-webpack-plugin` 插件，这个插件是用来处理 HTML，具有众多参数，上面使用的是常用的几种；
4. 运行

    ```shell shell
        webpack
    ```

    我们可以看到处理后的 `dist/index.html` 文件
    编译输出

    ```shell shell
        Hash: 7aa0102e3b8ba926d4bd
        Version: webpack 3.10.0
        Time: 741ms
            Asset       Size  Chunks             Chunk Names
        bundle.js      19 kB       0  [emitted]  entry
        index.html  382 bytes          [emitted]
        [0] ./src/entry.js 36 bytes {0} [built]
        [1] ./src/css/index.css 1.1 kB {0} [built]
        [2] ./node_modules/_css-loader@0.28.7@css-loader!./src/css/index.css 217 bytes {0} [built]
            + 3 hidden modules
        Child html-webpack-plugin for "index.html":
            1 asset
            [0] ./node_modules/_html-webpack-plugin@2.30.1@html-webpack-plugin/lib/loader.js!./src/index.html 707 bytes {0} [built]
            [2] (webpack)/buildin/global.js 509 bytes {0} [built]
            [3] (webpack)/buildin/module.js 517 bytes {0} [built]
                + 1 hidden module
    ```
    最终目录

    ```shell tree
        .
        ├── dist
        │   ├── bundle.js
        │   └── index.html
        ├── package.json
        ├── src
        │   ├── css
        │   │   └── index.css
        │   ├── entry.js
        │   └── index.html
        └── webpack.config.js
    ```
    
******

## 参考

链接 | 描述
---|---
[webpack 中文](https://doc.webpack-china.org/concepts/#loader) | 第二好的学习文档
[纯金 - Webpack 3.X版本 成神之路](https://www.chungold.com/course/32) | 说的十分高大上，但是也仅仅是一个入门 webpack 教程，适合对 webpack 一知半解的人加强对 webpack 的了解
 | 