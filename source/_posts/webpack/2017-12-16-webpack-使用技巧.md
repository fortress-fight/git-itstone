---
title: webpack 使用技巧
tags:
  - webpack
  - 自动化
  - 前端
categories:
  - 自动化
  - webpack
folder: Webpack
abbrlink: fdaa3ad2
date: 2017-12-16 22:25:08
photo: /xmind/webpack/使用技巧.png
---

webpack 是工具，用于处理工作或者开发中的问题，在面对真实的开发时候，还是存在一些有用的技巧的

<!-- more -->

{% img /xmind/webpack/使用技巧.detail.png %}

# webpack 使用

基于 webpack 3.* 的学习

## 部署

```bash tree
    .
    ├── dist
    │   └── bundle.js
    ├── entry.js
    ├── package.json
    ├── src
    └── webpack.config.js
```

## 开发和生产环境

在实际工作中，我们常常要对开发环境和生产环境进行区别对待，对于开发环境我们要保留调试，不在乎代码是否被压缩，以及使用本地地址；而在生产环境下我们需要对代码进行处理，才能将代码部署到显示；如果每一次切换环境，都是深入到自动化执行代码中去修改参数，未免失去了自动化的优势；这时我们需要通过制定的参数，让 webpack 执行相应的工作；

### 处理命令行参数

1. webpack 是运行在 node 环境下的，在接收命令行参数的时候使用的是 node 语法 `process.env` 命令行参数将会挂载到这个属性下；通过 process.env.type 的值，我们就可以判断要运行的代码；

    如何设置参数

    ```json package.json
        "scripts": {
            # win
            dev: set type=dev&webpack
            # ios
            dev: export type=dev&&webpack
        } 
    ```

    接受参数

    ```js webpack.config.js
        process.env.type
    ```

2. 我们还可选择使用 webpack 给的命令行环境配置的功能进行设置，通过使用 `--env.<key>=<value>` 向 webpack.config.js 中传入参数

    如何设置参数

    ```json package.json
        "scripts": {
            "dev": "webpack --env.NODE_ENV=development",
            "pro": "webpack --env.NODE_ENV=production"
        }
    ```

    {% blockquote %}
        这里 NODE_ENV 通常是约定用于定义环境类型的变量名
        如果设置了 env 变量，但是没有对其赋值，那么将会置这个变量为 `true`;
        例如： `--env.production` 将默认为 `--env.production=true`
    {% endblockquote %}

    如果接受参数
    webpack 通过命令行的形式，将参数传入到 `webpack.config.js` 中，如果在文件中想要接受到传递过来的参数，就需要对文件进行修改，将输出对象的形式改成输出函数的形式

    ```js
        module.export = env => {
            console.log(env.NODE_ENV)
            return: {
                ...
                entry: {
                    ...
                },
                output: {
                    ...
                }
                ...
            }
        }
    ```

无论是从哪个方面看，都是第二种方式更好

### 管理本地依赖以及生产依赖

> devDependencies -- 本地依赖
> dependencies -- 生产依赖

我们在安装 `npm` 包的时候，通常使用三种方式，以 jquery 为例：

1. `cnpm install jquery`
    这种是系统安装，不会进入 package.json 中，不受到管理; 如果系统中存在，其余安装将会选择直接拷贝过来；

2. `cnpm install jquery --save`
    在 package.json 中的 dependencies 中进行管理，意味着这个将会作为环境搭建的必要依赖

3. `cnpm install --save -dev jquery`
    这种是指 jquery 将会作为本地依赖使用(devDependencies)；

******

## 模块化配置

模块化这里并不是指什么特殊的配置，而是指一种概念：将一个文件分割成为独立模块，然后彼此之间通过 暴露 <=> 引入 的方式，搭建关系；

我们可以将 webpack.config.js 进行拆解，并通过 CommondJS 的语法方式进行 暴露、引入 等操作，这样将会十分有利于我们对 webpack.config 进行管理

******

## 打包第三方类库

第三方类库是指：jquery 等功能插件，在项目中引入，如果是下到本地，那可以按照本地文件的处理方式处理；如果是通过 `npm` 下载的，就需要使用另一种引入方法；

### 打包第三方类库实际操作

1. 方法一：我们可以通过 `cnpm i --save jquery` 的方式下载 jquery , 然后在入口文件中通过 `import` 进行引入：

    ```js entry.js
        import $ from 'jquery'
    ```

2. 方法二：使用 webpack 自带的一个插件 `ProvidePlugin`

    webpack 其实自身带了很多常用插件，我们可以在 `webpack.config.js` 中使用；

    ```js webpack.config.js
        const webpack = require('webpack');

        ...
        plugins: [
            new webpack.ProvidePlugin ({
                $: 'jquery'
            })
        ]
        ...
    ```
    使用 `webpack.ProvidePlugin` 的好处是，插件只有在使用的时候才会被打包进去

但是这俩个方法都存在问题：如果我们将第三方类库都引入到入口文件中，将会导致打包出去的文件变得十分庞大。所以我们希望能够将 jquery 作为一个单独的引入；

为了解决这个问题，我们需要将 jquery 抽离出来 --> 抽离一个文件作为独立的 js，其实需要先由多入口引入，然后告诉 webpack 那个文件你不要给我打包到一起了；

1. 方法一： 修改 `webpack.config.js`

    ```js webpack.config.js
        entry: {
            bundle: path.resolve(__dirname, 'entry'),
            jquery: 'jquery'
        },
        output: {
            path: path.resolve(__dirname, 'dist'),
            filename: '[name].js'
        },
    ```
    
2. 方法二：使用 webpack 的插件 `optimize.CommonsChunkPlugin(options)`

    {% blockquote %}
    CommonsChunkPlugin 插件，是一个可选的用于建立一个独立文件(又称作 chunk)的功能，这个文件可以包括多个入口 chunk 的公共模块。通过将公共模块拆出来，**最终合成的文件能够在最开始的时候加载一次**，便存起来到缓存中供后续使用。这个带来速度上的提升，因为浏览器会迅速将公共的代码从缓存中取出来，而不是每次访问一个新页面时，再去加载一个更大的文件。
    {% endblockquote %}

### CommonsChunkPlugin

CommonsChunkPlugin 是一个 webpack 的插件，这个插件主要是处理入口文件的；这里简单的介绍一下他的功能：分析多文件引入时，各个文件有没有相同的依赖，如果有就将其提取出来。
`CommonsChunkPlugin` 的参数，具体可以查看 [webpack-文档](https://doc.webpack-china.org/plugins/commons-chunk-plugin/#src/components/Sidebar/Sidebar.jsx)

基本参数：

1. name -- 引入的 chunk 名，如果存在就直接引入，如果不存在将，将会创建，如果是一个数组，数组最右侧的将会最先加载，提取的公用模块将会存在在最左侧位置
2. minChunks -- 引用次数，只有超出这个次数的才会被提取
3. chunks -- 如果没有将会对所有 chunk 进行处理，如果制定了一些，将会仅对这些处理


示例：多个文件同时引入，但是每个文件都依赖 `jquery`，这个时候就会将 `jquery` 提取出来进行单独管理

1. 创建多个入口文件

    ```js entry.js
        import 'src/script1'
    ```

    ```js script1
        import 'jquery';
    ```

    ```js script2
        import 'jquery';
    ```
1. 修改 webpack.config.js

    ```js webpack.config.js
        module.exports = {
            entry: {
                bundle: path.resolve(__dirname, 'entry'),
                script1: path.resolve(__dirname, './src/js/script1'),
                script2: path.resolve(__dirname, './src/js/script2')
            },
            output: {
                path: path.resolve(__dirname, 'dist'),
                filename: '[name].js'
            },
            plugins: [
                new webpack.optimize.CommonsChunkPlugin({
                    name: ['chunk'],
                    minChunks: 2
                }),
                new htmlWebpck({
                    minify: {
                        removeAttributeQuotes: true
                    },
                    hash: true,
                    template: './src/index.html'
                })
            ]
        }
    ```
1. 运行

    ```bash
        webpack
    ```

    输出

    ```bash
            Asset       Size  Chunks                    Chunk Names
        script2.js  427 bytes       0  [emitted]         script2
        bundle.js  340 bytes       1  [emitted]         bundle
        script1.js   25 bytes       2  [emitted]         script1
        chunk.js     275 kB       3  [emitted]  [big]  chunk
        index.html  566 bytes          [emitted]
        [1] ./entry.js 57 bytes {1} [built]
        [2] ./src/js/script1.js 16 bytes {3} [built]
        [3] ./src/js/script2.js 16 bytes {0} [built]
    ```

    这里可以看到 jquery 被单独抽离到了 chunk.js 中，其余文件仅仅包括基础代码

******

## watch -- 监控

webpack --watch 对文件进行监控，一旦文件发生修改将会直接运行 webpack，注意：这里的页面更新并不是局部更新，而是对整个页面刷新

webpack.config.js 配置

```js
    module.exports = {
        ...
        watchOptions: {
            // ms 监视的频率
            poll: 1000,
            // 间隔 防止重复按键导致的重复编译
            aggregeateTimeout: 500,
            // 排除检测文件, 正则筛选
            ignored: /node_modules/,

        }
        ...
    }
```

如果没有生效，可以使用插件：new webpack.HotModuleReplacementPlugin() 

******

## 静态资源

如果我们有一些静态资源，并不想通过 webpack 进行打包处理，页面也不一定对其都引入了，那么我们应该如何处理；

在这里我们可以使用插件 `copy-webpack-plugin`

### 拷贝静态资源

1. 安装 `cnpm i copy-webpack-plugin`
2. 修改 `webpack.config.js`

    ```js webpack.config.js
        const copyWebpckPlugin = require('copy-webpack-plugin'); 
        new copyWebpckPlugin([{
            from: 'src/img',
            to: 'public'
        }])
    ```
3. 运行

    ```bash
        webpack
    ```

    输出

    ```bash
                  Asset       Size  Chunks                    Chunk Names
            bundle.js  334 bytes       0  [emitted]         bundle
            script1.js     275 kB       1  [emitted]  [big]  script1
            index.html  420 bytes          [emitted]
        public/62kb.png    62.1 kB          [emitted]
    ```

******

## JSON 的引入

因为 JSON 文件没有 `module.exports`, 那么 webpack 中如何引入 JSON 文件？

### JSON 引入操作

1. 编写 JSON 文件

2. 引入

    ```js
        const ceshijson = require('./ceshi.json');
    ```

3. 目录

    ```bash tree
        .
        ├── ceshi.json
        ├── dist
        │   ├── bundle.js
        │   ├── index.html
        │   ├── public
        │   │   └── 62kb.png
        │   └── script1.js
        ├── entry.js
        ├── package.json
        ├── src
        │   ├── img
        │   │   └── 62kb.png
        │   ├── index.html
        │   └── js
        │       ├── script1.js
        │       └── script2.js
        └── webpack.config.js
    ```

******

## TIP

1. webpack.BannerPlugin("nihao"); 这个是用于打包时保留文件头部注释的 webpack 自带插件

# 参考

链接 | 描述
---|---
[纯金 - Webpack 3.X版本 成神之路](https://www.chungold.com/course/32) | 说的十分高大上，但是也仅仅是一个入门 webpack 教程，适合对 webpack 一知半解的人加强对 webpack 的了解
[webpack 中文文档--使用变量](https://doc.webpack-china.org/guides/environment-variables/) | 讲的十分简单易懂，还有示例
[webpack 中文文档--抽离](https://doc.webpack-china.org/plugins/commons-chunk-plugin/#src/components/Sidebar/Sidebar.jsx) |
[技术胖博客](http://jspang.com) | 东西比较多，但是讲的都是比较浅显的东西 