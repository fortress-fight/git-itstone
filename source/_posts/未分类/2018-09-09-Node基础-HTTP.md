---
title: Node基础-HTTP
tags:
  - Node
folder:
  - 待分类
floder: Node
category: Node
abbrlink: 20a052b7
date: 2018-09-09 16:09:36
---

---

<!-- more -->

HTTP -- 超文本传输协议，属于 TCP 的上层协议

## HTTP 结构

HTTP 结构构建在请求和响应的概念上，对应在 NodeJS 中是由 `http.ServerRequest` 和 `http.ServerResponse` 这两个构造器构造出来的对象；

当用户浏览一个网站的时候，客户端会创建一个请求，该请求通过 TCP 发送到 Web 服务端，服务端就会给出响应；

1. 创建服务

    ```js
    const HTTP = require('http');

    HTTP.createServer((req, res) => {
    	res.writeHead(200);
    	res.end('Hello World');
    }).listen(3000);
    ```

2. 发送请求

    ```bash
    telent 127.0.0.1 3000
    GET / HTTP/1.1
    ```

    响应：

    ```bash
    HTTP/1.1 200 OK
    Date: Sun, 09 Sep 2018 08:23:59 GMT
    Connection: keep-alive
    Transfer-Encoding: chunked

    b
    Hello World
    0
    ```

### 头信息

HTTP 协议是进行文档交换，他在请求和响应消息前使用头信息（header）来描述不同的消息内容

1. `Content-Type` 标注发送内容的类型

    ```js
    const HTTP = require('http');

    HTTP.createServer((req, res) => {
    	res.writeHead(200, {
    		'Content-Type': 'text/html'
    	});
    	res.end('Hello <b>World</b>');
    }).listen(3000);
    ```

    这样浏览器就能识别其实 HTML，并对其进行渲染；
    在调用 `end` 前，我们可以多次调用 `write` 方法来发送数据，为了尽可能地响应客户端，在首次调用 `write` 时，Node 就能够把所有的响应头信息以及第一块数据发送出去。

2. Transfer-Encoding
   Transfer-Encoding 头信息的默认值实 `chunked`
3. Connection
   Connection 的默认值为 `keep-alive`

### Node 的文件读取

Node 允许以数据块的形式往响应中写数据，同事他又允许以数据块的形式读取文件，所以我们可以使用 `ReadStream` 文件系统来实现文件的读取

```js
const HTTP = require('http');

HTTP.createServer((req, res) => {
	res.writeHead(200, {
		'Content-Type': 'image/png'
	});
	let stream = require('fs').createReadStream('./image.jpg');

	stream.on('data', data => {
		res.write(data);
	});

	stream.on('end', () => {
		res.end();
	});
}).listen(3000);
```

### HTTP & TCP

HTTP & TCP 的服务器的实现，都调用了 `createServer` 方法，并且当客户端连入的时候都会执行一个回调函数。

1. 在 HTTP 的会调用中传入的是请求和响应对象而在 TCP 中传入的是连接对象（connection）

    - HTTP 服务器是更高层的 API，提供了控制和 HTTP 协议相关的一些功能
      在 Node 内部 ，拿到浏览器发送的数据后，对其进行分解，然后构造了一个 `javascript` 对象方便我们在脚本中使用。

        ```json
        {
        	"host": "127.0.0.1:3000",
        	"user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.81 Safari/537.36",
        	"accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8",
        	"accept-encoding": "gzip, deflate, br",
        	"accept-language": "zh-CN,zh;q=0.9",
        	"proxy-connection": "keep-alive",
        	"upgrade-insecure-requests": "1"
        }
        ```

    - 浏览器在访问站点时不会就只用一个连接。很多主流的浏览器为了更快地加载网站内容，能像同一个主机打开八个不同的连接，并发送请求

    我们可以通过 `req.connection` 中获取 TCP 连接对象，Node 对其进行了抽象。

默认情况下，Node 会告诉浏览器始终保持连接（Connection:keep-alive），我们可以对齐重写

## 一个简单的 Web 服务器

目标：web 浏览器是如何在表单提交时传递编码的数据的，以及如何将他们解析为 JavaScript 中的数据结构

### 创建模块

```package.json
{
  "name": "http-form",
  "version": "0.0.1",
  "description": "An HTTP server that processes forms",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC"
}
```

### 输出表单

```js
const HTTP = require('http');

HTTP.createServer((req, res) => {
	res.writeHead(200, {
		'Content-Type': 'text/html'
	});
	res.end(
		[
			'<form method="POST" action="/url">',
			'<h1>My Form</h1>',
			'<fieldset>',
			'<label>Personal information</label>',
			'<p>what is your name:</p>',
			"<input name='name' type='text'>",
			'<p><button>Submit</button></p>',
			'</form>'
		].join('')
	);
}).listen(3000);
```

这时，页面输出一个表单但点击提交时，页面地址发生了变化，但是页面依旧没有发生变化，这时因为 Node 能够对表单提交的请求没有做出正确的处理，我们需要检测提交内容，以及 URL；

### method 和 URL

我们可以通过 `req.url` 可以得到当前页面路径；`req.method` 可以得到请求方法

NodeJS 将会把主机名后所有的内容都放在 `url` 属性中

### 数据

```js
const HTTP = require('http');

HTTP.createServer((req, res) => {
	if (req.url == '/') {
		res.writeHead(200, {
			'Content-Type': 'text/html'
		});
		res.end(
			[
				'<form method="POST" action="/url">',
				'<h1>My Form</h1>',
				'<fieldset>',
				'<label>Personal information</label>',
				'<p>what is your name:</p>',
				"<input name='name' type='text'>",
				'<p><button>Submit</button></p>',
				'</form>'
			].join('')
		);
	} else if (req.url == '/url' && req.method == 'POST') {
		var body = '';
		req.on('data', chunk => {
			body += chunk;
		});

		req.on('end', () => {
			res.writeHead(200, {
				'Content-Type': 'text/html'
			});
			res.write('You sent a <em>' + req.method + '</em> request');
			res.end(
				'<p> Content-Type:' +
					req.headers['content-type'] +
					'</p>' +
					'<p>Data:</p><pre>' +
					body +
					'</pre>'
			);
		});
	}
}).listen(3000);
```

数据接收的时候会触发 `data` 事件，当数据接收完成后会触发 `end` 事件

-   补充

    Node 中提供了一个 `querystring` 的模块，可以方便的对查询字符串进行解析

    示例：`require('querystring).parse('name="stone"')`

    结果：`{name: "stone"}`

### 404

如果 URL 没有匹配到任何判断条件，服务器端将会一直没有响应，浏览器一直都处于挂起状态

```js
...
} else {
    res.writeHead(404);
    res.end('<NOT FOND>');
}
```

## Web 服务器 & Web 客户端

服务端：

```js
const HTTP = require('http');

HTTP.createServer((req, res) => {
	res.writeHead(200);
	res.end('Hellow World');
}).listen(3000);
```

客户端：

```js
const HTTP = require('http');

HTTP.request(
	{
		host: '127.0.0.1',
		port: 3000,
		url: '/',
		method: 'GET'
	},
	res => {
		var body = '';
		res.setEncoding('utf8');
		res.on('data', chunk => {
			body += chunk;
		});
		res.on('end', () => {
			console.log('\n We got: \033[96m' + body + '\033[39m\n');
		});
	}
).end();
```

这里调用了 `request` 方法，创建了一个新的 `res` 对象；

我们收集信息块的方式和此前在服务器端收集客户端消息快的方式一样，链接的远程服务器会返回不同的数据块，我们需要将他们全部收集后才能得到完整的响应。需要监听 `res` 的 `end` 事件

### 表单

服务端：

```js
const HTTP = require('http');
const QS = require('querystring');

HTTP.createServer((req, res) => {
	var body = '';
	req.on('data', chunk => {
		body += chunk;
	});
	req.on('end', () => {
		res.writeHead(200);
		res.end('Done');
		console.log(
			'\n got name \033[90m' + QS.parse(body).name + '\033[39m\n'
		);
	});
}).listen(3000);
```

客户端：

```js
const HTTP = require('http');
const QS = require('querystring');

let send = theName => {
	HTTP.request(
		{
			host: '127.0.0.1',
			url: '/',
			port: 3000,
			method: 'POST'
		},
		res => {
			res.setEncoding('utf8');
			// 如果没有监听 `data` 事件 `end` 事件就不会执行
			res.on('data', () => {});
			res.on('end', () => {
				console.log('\n \033[90m request complete!\033[39m');
				process.stdout.write('\n your name:');
			});
		}
	).end(
		QS.stringify({
			name: theName
		})
	);
};

process.stdout.write('\n your name: ');
process.stdin.resume();
process.stdin.setEncoding('utf-8');
process.stdin.on('data', name => {
	send(name.replace('\n', ''));
});
```
