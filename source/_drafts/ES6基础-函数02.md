---
title: ES6基础-函数02
abbrlink: d51a3137
date: 2017-12-29 01:02:51
tags:
photo: /xmind/ES6/函数.png
---

******

<!-- more -->

# ES6基础-函数02

******

## 箭头函数

示例：

```js learn02-01
    // 01

    // let example = () => 'example';
    // console.log(example()) // example

    // 相当于

    let example = function () {
        return 'example'
    };

    console.log(example());
```

箭头函数与传统函数之间的区别主要有一下几个方面

区别 | 描述
---|---
没有 this super arguments 和 new.target 绑定 | 箭头函数本身没有这些属性，在箭头函数中的这些值是通过作用域链向上查找，是由外围最近一层非箭头函数决定的；
不能通过 new 关键字调用 | 箭头函数中没有 [[Construct]] 方法，所以不会被用作构造函数
不具有原型属性（prototype） | 由于不能 `new` ，所以也不存在 `prototype` 属性
不支持 this 绑定 | 函数内部的 this 值不能变换
不支持 arguments 绑定 | 
不支持重复的命名 | 

使用箭头函数的好处：

1. this 不再发生变化
2. this 不再变化后，浏览器渲染的时候就可以只考虑到一级
3. 箭头函数遵从用完即弃

### 箭头函数语法

箭头函数的语法多样，但是所有的箭头函数都是通过参数、箭头以及函数体组成：`参数 => 函数体`；

示例：

```js learn02-03
    let example = value => value;

    console.log(example("将会直接返回")); // 将会直接返回

    // 相当于

    function example1 (value) {
        return value;
    }

    console.log(example1("将会直接返回")) // 将会直接返回
```

1. 参数

    在箭头函数中，根据不同的参数具有不同的语法形式，示例 03 中，是当函数只存在一个参数的时候，另外还存在无参数以及多个参数的语法：

    ```js learn02-04

        // 04

        let example = () => console.log('执行了')

        example(); // '执行了'

        let example2 = (num1, num2) => console.log(num1 + num2);

        example2(10, 20) // 30
    ```

    从上述示例看出，在箭头函数中，如果只有一个参数的情况下，我们可以省略包裹参数的小括号；

2. 函数体

    在箭头函数中，函数体也根据不同的情况会有不同的表现语法，在示例 03 中，我们可以看出如果只有一条语句时，可以将其直接写在箭头后面，并且箭头函数将会返回这条语句的结果；
    除此之外，我们还存在多个函数执行语句情况；

    ```js learn02-05
        // 05

        let example = (name) => {
            let init = "你好";
            return init + name;
        }
        console.log(example("es2015")); // 你好es2015

        // 如果想通过箭头函数创建一个空的函数：
        let example2 = () => {};
    ```

    注意：如果只想返回一个对象，这样写将不会得到想要的结果；

    ```js learn02-06
        let example = () => {
            name: 'es6'
        }

        console.log(example()) // undefined
    
    ```

    需要改为：
    
    ```js learn02-06

        let example02 = () => ({
            name: 'es6'
        });

        console.log(example02()) //{ name: 'es6' }
    ```

### 通过箭头函数创建立即执行函数表达式

立即执行函数表达式，在 JavaScript 中还是比较常见的，常用于创建隔离的作用域,并且可以做到不保存对于该函数的引用；通过箭头函数同样也可以很方便的实现

```js learn02-07
    
    let example = ((name) => {
        let init = "Hello";
        return init + name;
    })("es6");

    console.log(example) // Helloes6
```

### 箭头函数中的 this

之前，在 JavaScript 中，最容易让人产生困惑的应该是函数中 this 的指向问题了；通常来时，函数中的 this 指向于函数执行时的调用函数的上下文；

示例

```js learn02-08
    let example = {
        id: '08',
        _showId: function () {
            console.log(this, this.id)
        },
        showId: function () {
            setTimeout(function () {

                console.log(this, this.id)
            }, 200)
        },
        arrowShowId: function () {
            setTimeout(() => {
                console.log(this, this.id)
            }, 200);
        }
    }

    example.showId(); // window undefined
    example._showId(); // example 08
    example.arrowShowId(); // example 08
```

在调用 `example.showId` 的时候，我们可以看到 `setTimeout` 中执行函数，在执行的时候函数的上下文是 `window` 对象，所以就绑定到了 `window` 上了，这个肯定不是我想要得到的结果；
在调用 `example.arrowShowId` 的时候，使用了箭头函数；在箭头函数中不存在 this，所以需要通过查找作用域链来决定其值，如果**箭头函数被费箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则 this 的值将会被设置为 undefined**

> 注意：箭头函数中的 this 不能通过 `call/apply/bind` 的方法改变

箭头函数 this 不随着函数执行上下文的改变而改变，有好有坏，具体使用需要视情况而定，不可矫枉过正；

******

## 块级函数

ECMAScript 3 中规定，在代码块中声明一个块级函数严格来说是一个语法错误，但是在所有的浏览器中都支持了这个特性（如果使用了严格模式，将会抛出语法错误）。不过在不同的浏览器中又存在着些许的不同；所以不建议在代码块中声明一个函数；

```js 
    // 这种行为是一种语法错误
    if (true) {
        function example () {};
    }
```

在 ES6 中，会将代码块中的 example 视作一个块级声明，从而可以在定义该函数的代码块中访问和调用他；

```js 
    // console.log(example); // undefind

    // if (true) {
    //     function example () {};
    //     console.log(example); // [Function]
    // }
    // console.log(example); // [Function]

    "use strict"
    console.log(example); // example is not defined

    if (true) {
        function example () {};
        console.log(example); // [Function]
    }
    console.log(example); // [Function]
```

可以看出在非严格模式下，代码块中的 example 将会提升到全局域中，所以在 `if` 下面可以访问到。但是 example 并没有通过预编译，所以在 `if` 上面并没有访问到，

## name 属性

函数在 JavaScript 中存在很多种定义方式，通过函数的 name 属性，有助于我们迅速找到相应函数，提高调试效率

示例：

```js learn02-02

    function name1() {}
    let name2 = function () {};
    let name3 = function name4() {};

    console.log(name1.name); // name1
    console.log(name2.name); // name2
    console.log(name3.name); // name3
    // console.log(name4.name); // name4 is no define

    console.log(new Function().name); // anonymous
    console.log(function () {}.bind(null).name); // bound

```

> 绝对不能使用 name 属性的值，来获取对于函数的引用

## 增强的 Function 构造函数

通过 `Function` 的构造函数来创建一个函数，并不是特别常用，并且也不建议通过这种方式进行创建，这里只做简单的介绍

```js
    let example = new Function (<参数>， [参数], ... , <执行函数>)
```

## 明确函数的多重用途

示例：

```js learn02-09
    function Person (name) {
        this.name = name
    }

    let person1 = new Person();
    let person2 = Person();

    console.log(typeof person1, typeof person2) // object undefined
```

我们可以看到，使用或者不使用 `new` 将会有不同的输出；当然 `new` 操作符，将会对函数参数一些影响；在 ES6 中，丢这种行为的细节有了进一步的说明；

在 JavaScript 中函数有两个不同的内部方法，`[[Call]]` 和 `[[Construct]]`; 当使用 `new` 关键字调用函数的时候，执行的就是 `[[Construct]]` 它负责创建一个通常内称作是实例的新对象，然后执行函数体，将 this 绑定到实例上，并返回该实例对象；如果没有使用 `new` 操作符，将会执行 `[[Call]]` 函数，从而直接指向代码中的函数体；

具有 `[[Construct]]` 方法的将统称为构造函数；

> 不是所有的函数都具有 `[[Construct]]` 方法（箭头函数就没有），而没有该方法的就不能通过 `new` 操作符进行调用；

### 判断函数被调用的方法

如果我们希望确定一个函数是否是在通过 `new` 操作符进行调用的，就需要我们使用一些特殊的方法；

1. ES5 中

    在 ES5 中 我们可以通过 `instanceof` 方法查看执行时，实例对象是不是在构造函数的原型链上来进行判断

    ```js learn02-10

        // 10

        function example () {
            if (this instanceof example) {
                console.log('通过 new 操作符来进行调用的')
            } else {
                console.log('直接执行了函数体')
            }
        }

        example(); // 直接执行了函数体
        let ex = new example() // 通过 new 操作符来进行调用的

    ```

2. ES6

    在 ES6 中，我们可以通过 `new.target` 来进行判断

    ```js learn02-11

        function example () {
            if (new.target) {
                console.log('通过 new 操作符来进行调用的')
            } else {
                console.log('直接执行了函数体')
            }
        }

        example(); // 直接执行了函数体
        let ex = new example() // 通过 new 操作符来进行调用的
    ```

    `new.target` 必须是在函数体中使用；其将会在 `[[Contruct]]` 调用的时候，就会被赋值为 `new` 操作符的目标，通常是新创建的对象实例；

3. 为什么要知道函数是通过何种方式调用

    在函数调用的时候，使用者的行为是不可控的，所以我们可以通过判断调用方式，抛出相应提示；

    如果我们希望只能 `new` 一个指定的构造函数来创建，也可以通过判断来决定是否创建实例；

    实用示例：

    ```js 
        function e(obj) {
            if (obj instanceof e) return obj;
            if (!(this instanceof e)) return new e(obj);
        }
        // 如果传入的是 e 的实例，将直接返回；如果不是并且没有调用 [[Construct]] 将会调用 new e(obj) 来创建 e 的实例
    ```

******

{% img '/xmind/ES6/函数.detail.png' %}

******

# 未完成

{% blockquote  %}

1. 尾调优化  -- 尾调优化，目前使用不到；是通过优化调用栈来优化系统的引擎c

{% endblockquote  %}
