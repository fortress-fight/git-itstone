---
title: 迭代器与生成器
date: 2018-08-07 23:39:45
tags:
  - JavaScript
  - ES6
  - 迭代器与生成器
folder:
  - ES6
category:
  - JavaScript
---

---

<!-- more -->

## 迭代器基础

通过程序化的方式使用迭代器对象返回迭代过程中集合每一个元素，可以简化数据操作。在 ES6 中很多的特性都依赖了迭代器特性。

1.  `Set` 集合与 `Map` 集合
2.  新的 `for-of` 循环
3.  展开运算符
4.  异步编程也可以使用迭代器

-   循环语句的问题

    ```js
    var arr = ["a", "b", "c"];
    for (var i = 0, len = arr.length; i < len; i++) {
        console.log(arr[i]);
    }
    ```

    这是一段标准的 `for` 循环代码，如果将多个循环嵌套就需要跟踪多个变量。将会加大代码的复杂度。

    > 迭代器的出现就是为了消除这种复杂性并减少循环中的错误

-   迭代器

    迭代器是一个特殊的对象，包含：

    1.  `next()` 方法，每一次调用都会返回一个结果对象：`{value: 值, done: [Boolean]}`
        -   value: 表示下一个将要返回的值
        -   done: 表示是否有可返回值，如果没有更多的可返回数据就会返回 `true`;
            如果在最后一个值返回后再调用 `next()` 那么返回的 `done` 值为 `true`，`value` 将会包含迭代器最终的返回值。这个返回值不是数据集的一部分，是函数调用程序最后一次给调用者传递的值，如果不存在将会返回 `undefined`
    2.  一个内部指针，用来执行当前集合中值的位置

    我们可以通过 `ES5` 的方法创建一个迭代器

    ```js
    function createIterator(items) {
        let i = 0;
        return {
            next: function() {
                let done = i >= items.length,
                    value = !done ? items[i++] : undefined;

                return {
                    done,
                    value
                };
            }
        };
    }

    var iterator = createIterator([1, 2, 3, 4]);

    console.log(iterator.next()); // ​​​​​{ done: false, value: 1 }​​​​​;

    console.log(iterator.next()); // ​​​​{ done: false, value: 2 }​​​​​;

    console.log(iterator.next()); // ​​​​{ done: false, value: 3 }​​​​​;

    console.log(iterator.next()); // ​​​​{ done: false, value: 4 ​}​​;

    console.log(iterator.next()); // ​​​​{ done: true, value: undefined ​}​​;

    console.log(iterator.next()); // ​​​​{ done: true, value: undefined ​}​​;
    ```

    迭代器的规则比较复杂，在 ES6 中引入了生成器，可以让创建迭代器对象的过程变得简单

-   生成器

    生成器是一种返回迭代器的函数：`function* [name](){}`，函数内部包含关键字 `yield` [yield 只能在生成器中使用]；
    在对象中可以使用下面的方法创建迭代器：

    ```js
    let o = {
        *createIterator(items) {
            ...
        }
    };
    ```

    示例：

    ```js
    function* createIterator() {
        yield 1;
        yield 2;
    }

    var i2 = createIterator();

    console.log(i2.next()); // ​​​​​{ done: false, value: 1 }​​​​​;

    console.log(i2.next()); // ​​​​​{ done: false, value: 2 }​​​​​;

    console.log(i2.next()); // ​​​​​{ done: true, value: undefined }​​​​​;
    ```

    生成器特点：

    1.  每当执行完一条 `yield` 语句后，函数就会自动停止执行，直到再次调用迭代器的 `next` 方法才会继续执行
    2.  使用 `yield` 可以返回任何值或者表达式
    3.  使用 `yield` 只能在生成器中，它不能穿透函数边界也就是说，在生成器内部的函数的 `yield` 将会产生语法错误

    示例 2：

    ```js
    function* createIterator3(items) {
        for (var i = 0, len = items.length; i < len; i++) {
            yield items[i];
        }
    }

    var i3 = createIterator3([1, 2, 3]);

    console.log(i3.next());
    console.log(i3.next());
    console.log(i3.next());
    console.log(i3.next());
    ```

    > 不能使用箭头函数创建生成器

## 可迭代对象与 for-of 循环

具有 `Symbol.iterator` 属性的就是可迭代对象（生成器默认会添加，所以通过生成器创建的迭代器都是可迭代对象）； 可迭代对象是一种与迭代器密切相关的对象，`Symbol.iterator` 通过指定的函数可以返回一个作用于附属对象的迭代器；

以下对象具有默认的迭代器：

1.  数组
2.  Set 集合
3.  Map 集合
4.  字符串

for-of 循环需要用到可迭代对象的这些功能

for-of 循环没执行一次就会调用可迭代对象的 `next` 方法，并将迭代器返回的结果对象的 `value` 属性存在一个变量中。循环将持续执行这一过程直到返回的对象的 `done` 的值为 `true`。

> 相较于创痛的 for 循环，for-of 循环的控制条件更加简单，不需要追踪复杂的条件。
> 如果将 for-of 语句用于不可迭代的对象上，将会抛出错误

### 访问默认迭代器

可以通过 `Symbol.iterator` 来访问对象默认的迭代器

```js
let val = [1, 2, 3];
let i4 = val[Symbol.iterator]();
console.log(i4.next());
console.log(i4.next());
console.log(i4.next());
```

由于具有 `Symbol.iterator` 属性的对象都是默认的迭代器，所以可以通过它来检测对象是否是可迭代对象

```js
function isIterator(obj) {
    return typeof obj[Symbol.iterator] == "function";
}

console.log(isIterator([]));
```

### 创建可迭代对象

如果给对象添加一个 `Symbol.iterator` 属性，对这个属性添加一个生成器，则可以将其变为可迭代对象

```js
let collection = {
    items: [],
    *[Symbol.iterator]() {
        for (let item of this.items) {
            yield item + "：迭代";
        }
    }
};

collection.items.push(1);
collection.items.push(2);
collection.items.push(3);

for (let x of collection) {
    console.log(x);
}

// 1：迭代
// 2：迭代
// 3：迭代
```
